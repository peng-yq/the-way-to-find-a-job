#### Redis的底层数据结构

Redis是一个开源的、基于内存的、使用C语言编写的key-value数据库。

Redis的基础数据类型及其对应的底层数据库如下：

| string         | list               | hash             | set                | sorted set     |
| -------------- | ------------------ | ---------------- | ------------------ | -------------- |
| 简单动态字符串 | 双向链表、压缩链表 | 哈希表、压缩链表 | 整数数组、压缩链表 | 跳表、压缩链表 |

底层实现的时间复杂度：

| 双向链表 | 双向链表 | 哈希表 | 整数数组 | 跳表    |
| -------- | -------- | ------ | -------- | ------- |
| O(n)     | O(n)     | O(1)   | O(n)     | O(logn) |

**可以看出除了 string 类型的底层实现只有一种数据结构，其他四种均有两种底层实现，这四种类型为集合类型，其中一个键对应了一个集合的数据；**

#### Redis键值如何存储

Redis 为了快速访问键值对，采用了**哈希表**来保存所有的键值对，一个哈希表对应了多个**哈希桶**，所谓的哈希桶是指哈希表数组中的每一个元素，当然哈希表中保存的不是值本身，是指向值的指针，如下图。

其中哈希桶中的 entry 元素中保存了*key 和*value 指针，分别指向了实际的键和值。通过 Redis 可以在 O(1)的时间内找到键值对，只需要计算 key 的哈希值就可以定位位置，但从下图可以看出，在 4 号位置出现了冲突，两个 key 映射到了同一个位置，这就产生了哈希冲突，会导致哈希表的操作变慢。**虽然 Redis 通过链式冲突解决该问题，但如果数据持续增多，产生的哈希冲突也会越来越多，会加重 Redis 的查询时间**；

<img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvPRGjmLLqO9OW5TRrdLttdmpVfzlRCBa7PNI2K8Pd7icuibT6C9nVxa3gQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

为了解决上述的哈希冲突问题，**Redis 会对哈希表进行rehash操作，也就是增加目前的哈希桶数量，使得 key 更加分散，进而减少哈希冲突的问题**，主要流程如下：

1. 采用两个 hash 表进行操作，当哈希表 A 需要进行扩容时，给哈希表 B 分配两倍的空间；
2. 将哈希表 A 的数据重新映射并拷贝给哈希表 B；
3. 释放 A 的空间。

上述的步骤可能会存在一个问题，当哈希表 A 向 B 复制的时候，是需要一定的时间的，可能会造成 Redis 的线程阻塞，就无法服务其他的请求了。

针对上述问题，Redis 采用了**渐进式 rehash（过程类似redis删除key的定期删除和惰性删除）**，主要的流程是：**Redis 还是继续处理客户端的请求，每次处理一个请求的时候，就会将该位置所有的 entry 都拷贝到哈希表 B 中，当然也会存在某个位置一直没有被请求。Redis 也考虑了这个问题，通过设置一个定时任务进行 rehash，在一些键值对一直没有操作的时候，会周期性的搬移一些数据到哈希表 B 中，进而缩短 rehash 的过程**。

#### Redis为什么使用单线程

Redis的单线程指网络I/O和键值对读写由一个线程来完成，bgsave、bgwriteaof等持久化操作由额外的线程执行。

单线程避免了线程切换和互斥同步的开销，通常情况下，使用多线程可以增加系统吞吐率或者可以增加系统扩展性。但其实对于多线程并发访问的控制一直是一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果。即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

**值得注意的是在 Redis6.0 中引入了多线程**。在 Redis6.0 之前，从网络 IO 处理到实际的读写命令处理都是由单个线程完成的，但随着网络硬件的性能提升，Redis 的性能瓶颈有可能会出现在网络 IO 的处理上，也就是说**单个主线程处理网络请求的速度跟不上底层网络硬件的速度**。针对此问题，Redis 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度，**但多 IO 线程只用于处理网络请求，对于读写命令，Redis 仍然使用单线程处理！**

#### Redis为什么单线程还这么快

1. Redis使用I/O多路复用机制，Reactor模型，I/O多路复用机制允许内核中同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果，进而提升并发性。通过Reactor模型，Redis将不同的事件分派给对应的事件处理器进行处理。
2. Redis基于内存，十分迅速。
3. Redis具有高效的底层数据结构，为优化内存，基本数据结构中除了string都有两种底层实现方式。
4. Redis采用单线程，**避免了不必要的上下文切换和资源竞争，不存在多线程导致的 CPU 切换和锁的问题；**

#### AOF

**AOF日志是先执行命令再写日志**：

1. AOF并不检查命令的正确性，因此先执行命令再写日志，避免错误的命令被记录，从而影响数据恢复，同时也不会阻塞当前的写操作。

AOF中的命令格式：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvPD0rd9GKYa53503u9Td3jvvbv55JG4AOEw3NUogaPV8wqHwr9Pian80w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

\*3表示命令分为3部分，\$3表示该部分命令、键、值多少字节。

#### AOF重写机制

**AOF 重写就是根据所有的键值对创建一个新的 AOF 文件**，可以减少大量的文件空间，减少的原因是：**AOF 对于命令的添加是追加的方式，逐一记录命令，但有可能存在某个键值被反复更改，产生了一些冗余数据，这样在重写的时候就可以过滤掉这些指令，从而更新当前的最新状态**。

AOF 重写的过程是通过主线程 fork 后台的 bgrewriteaof 子进程来实现的，可以避免阻塞主进程导致性能下降，整个过程如下：

- AOF 每次重写，fork 过程会把主线程的内存拷贝一份 bgrewriteaof 子进程，里面包含了数据库的数据，拷贝的是父进程的页表，可以在不影响主进程的情况下逐一把拷贝的数据记入重写日志；
- **因为主线程没有阻塞，仍然可以处理新来的操作，如果这时候存在写操作，会先把操作先放入缓冲区，对于正在使用的日志，如果宕机了这个日志也是齐全的，可以用于恢复；对于正在更新的日志，也不会丢失新的操作，等到数据拷贝完成，就可以将缓冲区的数据写入到新的文件中，保证数据库的最新状态**。

> 注意这里区别于RDB，RDB对于要修改的key是COW；AOF是写到缓冲区

#### RDB

bgsave 的命令来执行全量快照，提供了数据的可靠性保证，也避免了对 Redis 的性能影响。执行快照期间数据能不能修改呢?如果不能修改，快照过程中如果有新的写操作，数据就会不一致，这肯定是不符合预期的。Redis 借用了操作系统的**写时复制**，在执行快照的期间，正常处理写操作。

主要流程为：

- bgsave 子进程是由主线程 fork 出来的，可以共享主线程的所有内存数据；
- bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件中；
- 如果主线程对这些数据都是读操作，例如 A，那么主线程和 bgsave 子进程互不影响；
- 如果主线程需要修改一块数据，如 C，这块数据会被复制一份，生成数据的副本，然主线程在这个副本上进行修改；bgsave 子进程可以把原来的数据 C 写入 RDB 文件；

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvP7sRQk7XIzMveVufibxUSL5Wtd2FO7WhNsaopRLwzCj3rib0khA53WErA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

理论上来说快照时间间隔越短越好，可以减少数据的丢失，毕竟 fork 的子进程不会阻塞主线程，但是频繁的将数据写入磁盘，会给磁盘带来很多压力，也可能会存在多个快照竞争磁盘带宽（当前快照没结束，下一个就开始了）。**另一方面，虽然 fork 出的子进程不会阻塞，但 fork 这个创建过程是会阻塞主线程的，当主线程需要的内存越大，阻塞时间越长**；针对上面的问题，Redis 采用了**增量快照**，在做一次全量快照后，后续的快照只对修改的数据进行记录，需要记住哪些数据被修改了，可以避免全量快照带来的开销。

#### 混合使用AOF日志和RDB快照

在 Redis4.0 提出了**混合使用 AOF 和 RDB 快照**的方法，也**就是两次 RDB 快照期间的所有命令操作由 AOF 日志文件进行记录**。这样的好处是 RDB 快照不需要很频繁的执行，可以避免频繁 fork 对主线程的影响，而且 AOF 日志也只记录两次快照期间的操作，不用记录所有操作，也不会出现文件过大的情况，避免了重写开销。

通过上述方法既可以享受 RDB 快速恢复的好处，也可以享受 AOF 记录简单命令的优势。

**对于 AOF 和 RDB 的选择问题：**

- **数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；**
- **如果允许分钟级别的数据丢失，可以只使用 RDB；**
- **如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。**

#### Redis数据同步

当存在多个 Redis 实例的时候，可以通过 replicaof 命令形成主库和从库的关系，在从库中输入：**replicaof 主库 ip 6379** 就可以在主库中复制数据，具体有三个阶段：

- 首先是主从库建立连接、协商同步的过程：**从库向主库发送 psync 命令，代表要进行数据同步；psync 中包含了主库的 runID（Redis 启动时生成的随机 ID，初始值为：？）和复制进度 offset（设为-1，代表第一次复制）两个参数，主库接收到 psync 命令会，会用 FULLRESYNC 命令返回给从库，包含两个参数：主库 runID 和复制进度 offset；其中 FULLRESYNC 代表的全量复制，会将主库所有的数据都复制给从库**；
- 待从库接收到数据后，在本地完成数据加载：**主库执行 bgsave 命令，生成 RDB 文件，然后将文件发给从库，从库接收到 RDB 文件后，首先清空当前数据，然后再加载 RDB 文件；这个过程主库不会被阻塞，仍然可以接受请求，如果存在写操作，刚刚生成的 RDB 文件中是不包含这些新数据的，此时主库会在内存中用专门的 replication buffer 记录 RDB 文件生成后所有的写操作**；
- 最后，**主库会把 replication buffer 中的修改操作发给从库，从库重新执行这些操作**，就可以实现主从库同步了。

当然如果从库过多，主库就会频繁fork来生成RDB文件，fork这个过程是会阻塞主进程的，因此一般使用主-从-从的模式，或者设置从库从其它从库来复制同步。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvPuJnICz1xmrJDwM7MKT1ibYhAYKz5BXZ3SqMsHGuuAiadG9ICFzktYUaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

#### 主从切换

Redis 采用了**哨兵机制**应对这些问题，哨兵机制是实现主从库自动切换的关键机制，在主从库运行的同时，它也在进行**监控、选择主库和通知**的操作；

- **监控**。哨兵在运行时，周期性的给所有的主从库发送 PING 命令，检测是否仍在运行。如果从库没有响应哨兵的 PING 命令，哨兵就会将它标记为下线状态；如果主库没有在规定时间内响应哨兵的 PING 命令，哨兵也会判断主库下限，然后开始自动切换主库的流程。
- **选主**。主库挂了之后，哨兵需要按照一定的规则选择一个从库，并将他作为新的主库。
- **通知**。选取了新的主库后，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令和新主库建立连接，并进行数据复制；同时哨兵也会将新主库的消息发给客户端；

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvPkEhZaZxichLZ2AvW4icxykQlSKSlRViaGx7OzogBibaoK2sj425PEGEYoA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

哨兵至少3个，必须多数哨兵认为主库下线才是客观下线。

#### 哨兵如何选举新的主库

选取主库的过程分为**“筛选 和 打分”**。主要是按照一定的规则过滤掉不符合的从库，再按照一定的规则给其余的从库打分，将最高分的从库作为新的主库。

- **筛选**。首先从库一定是正在运行的，还要判断从库之前的网络连接状态，如果总是断连并且超过了一定的阈值，哨兵会认为该从库的网络不好，也会将其筛掉。

- **打分**。哨兵机制根据三个规则依次进行打分：**从库优先级、从库复制进度以及从库 ID 号**。**在某一轮有从库得分最高，那么它就是新的主库了，选主过程结束。如果该轮没有出现最高的，继续下一轮**。

  1. 优先级最高的从库。**用户可以通过 slave-priority 配置项，给不同的从库设置优先级**。选主库的时候哨兵会给优先级高的从库打高分，如果一个从库优先级高，那么就是新主库；

  1. 从库复制进度最接近。主库的 slave_repl_offset 和从库 master_repl_offset 越接近，得分越高；

  1. ID 小的从库得分高。**如果上面两轮也没有选出新主库，就会根据从库实例的 ID 来判断，ID 越小的从库得分越高**。

#### 哪个哨兵来执行主从库切换

这个过程和判断主库“客观下线”类似，也是一个投票的过程。如果某个哨兵判断了主库为下线状态，就会给其他的哨兵实例发送**is-master-down-by-addr**的命令，其他实例会根据自己和主库的连接状态作出 Y 或 N 的响应，Y 相当于赞成票，N 为反对票。一个哨兵获得一定的票数后，就可以标记主库为“客观下线”，这个票数是由参数 quorum 设置的。如下图：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvPWBAVHBkGzbFSU3WG5cTNFcjJRUeeLSicJQsUHnt3nDTeicP80u2FrVtg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

例如：现在有 3 个哨兵，quorum 配置的是 2，那么，一个哨兵需要 2 张赞成票，就可以标记主库为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。

这个时候哨兵就可以给其他哨兵发送消息，表示希望自己来执行主从切换，并让所有的哨兵进行投票，这个过程称为“Leader 选举”，进行主从切换的哨兵称为 Leader。任何一个想成为 Leader 的哨兵都需要满足两个条件：

- **拿到半数以上的哨兵赞成票；**
- **拿到的票数需要大于等于 quorum 的值。**

以上就可以选出 Leader 然后进行主从库切换了。

#### Redis集群

**Redis 的切片集群**可以解决这个问题，也就是启动多个 Redis 实例来组成一个集群，再按照一定的规则把数据划分为多份，每一份用一个实例来保存，这样客户端只需要访问对应的实例就可以获取数据。在这种情况下 fork 子进程一般不会给主线程带来较长时间的阻塞

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatMwzg6mhgDiaSmbXoDiaBzvP5nicibC71ibL8W0kSum5EYxXiabnJEOz06t5KPpkxKrcclV5XjrXQD39mg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">

选择切片集群也是需要解决一些问题的：

- 数据切片后，在多个实例之间怎么分布？
- 客户端怎么确定想要访问的实例是哪一个？

Redis 采用了 Redis Cluster 的方案来实现切片集群，具体的 Redis Cluster 采用了哈希槽（Hash Slot）来处理数据和实例之间的映射关系。**在 Redis Cluster 中，一个切片集群共有 16384 个哈希槽（[为什么 Hash Slot 的个数是 16384](https://www.cnblogs.com/rjzheng/p/11430592.html)），这些哈希槽类似于数据的分区，每个键值对都会根据自己的 key 被影射到一个哈希槽中，映射步骤如下：**

- **根据键值对 key，按照 CRC16 算法计算一个 16bit 的值；**
- **用计算的值对 16384 取模，得到 0 ～ 16383 范围内的模数，每个模数对应一个哈希槽。**

**这时候可以得到一个 key 对应的哈希槽了，哈希槽又是如何找到对应的实例的呢？**

**在部署 Redis Cluster 的时候，可以通过 cluster create 命令创建集群，此时 Redis 会自动把这些槽分布在集群实例上，例如一共有 N 个实例，那么每个实例包含的槽个数就为 16384/N**。当然可能存在 Redis 实例中内存大小配置不一的问题，内存大的实例具有更大的容量。这种情况下可以通过 cluster addslots 命令手动分配哈希槽。

#### 客户端定位集群中的数据

客户端请求的 key 可以通过 CRC16 算法计算得到，但客户端还需要知道哈希槽分布在哪个实例上。**在最开始客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端，实例之间会把自己的哈希槽信息发给和它相连的实例，完成哈希槽的扩散。这样客户端访问任何一个实例的时候，都能获取所有的哈希槽信息。当客户端收到哈希槽的信息后会把哈希槽对应的信息缓存在本地，当客户端发送请求的时候，会先找到 key 对应的哈希槽，然后就可以给对应的实例发送请求了**。

但是，哈希槽和实例的对应关系不是一成不变的，可能会存在新增或者删除的情况，这时候就需要重新分配哈希槽；也可能为了负载均衡，Redis 需要把所有的实例重新分布。虽然实例之间可以互相传递消息以获取最新的哈希槽分配信息，但是客户端无法感知这个变化，就会导致客户端访问的实例可能不是自己所需要的了。

**Redis Cluster 提供了重定向的机制，当客户端给实例发送数据读写操作的时候，如果这个实例上没有找到对应的数据，此时这个实例就会给客户端返回 MOVED 命令的相应结果，这个结果中包含了新实例的访问地址，此时客户端需要再给新实例发送操作命令以进行读写操作**，MOVED 命令如下：

```shell
GET hello:key
(error) MOVED 3333 33.33.33.33:6379
```

返回的信息代表客户端请求的 key 所在的哈希槽为 3333，实际是在 33.33.33.33 这个实例上，此时客户端只需要向 33.33.33.33 这个实例发送请求就可以了。

此时也存在一个小问题，哈希槽中对应的数据过多，导致还没有迁移到其他实例，此时客户端就发起了请求，在这种情况下，客户端就对实例发起了请求，**如果数据还在对应的实例中，会给客户端返回数据；如果请求的数据已经被转移到其他实例上，客户端就会收到实例返回的 ASK 命令，该命令表示：哈希槽中数据还在前一种、ASK 命令把客户端需要访问的新实例返回了。此时客户端需要给新实例发送 ASKING 命令以进行请求操作**；

值得注意的是 ASK 信息和 MOVED 信息不一样，**ASK 信息并不会更新客户端本地的缓存的哈希槽分配信息**，也就是说如果客户端再次访问该哈希槽还是会请求之前的实例，直到数据迁移完成。