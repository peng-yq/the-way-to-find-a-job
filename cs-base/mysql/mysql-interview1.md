#### 关系型和非关系型数据库

关系型数据库（RDBMS）的取名来源于所使用的关系模型。关系模型：使用表格形式组织数据，每个表都有行（记录）和列（属性），可以通过sql进行高效查询。比如MySQL。

非关系数据库（NoSQL）：不仅仅使用SQL作为查询语言，不遵循传统的关系模型，采用更灵活的数据模型。比如Redis、Mongodb，适合数据量大、高可用、日志系统、地理位置存储的场景。

主要区别

1. **数据模型**：
   - 关系型：表格模型，严格的数据结构。
   - 非关系型：多样化的数据模型，包括键值对、文档等。
2. **查询语言**：
   - 关系型：使用SQL，一个强大且标准化的查询语言。
   - 非关系型：查询方式因类型而异，没有统一标准。
3. **事务处理**：
   - 关系型：支持复杂的事务（一组操作，要么全部成功，要么全部不执行，特点是ACID）管理和ACID原则（原子性、一致性、隔离性、持久性）。
   - 非关系型：某些类型支持事务，但通常不如关系型数据库强大。
4. **扩展性**：
   - 关系型：通常支持垂直扩展（增加单个服务器的资源）。
   - 非关系型：设计用于水平扩展（增加更多服务器）。
5. **一致性和可靠性**：
   - 关系型：高一致性和可靠性。
   - 非关系型：侧重于可用性和分区容错性，可能采用最终一致性。

关系型数据库适合需要严格数据完整性和复杂查询的应用，而非关系型数据库则适合需要高扩展性和灵活数据模型的大规模应用。

#### 为什么使用索引

1. 唯一性索引保证数据库表中每一行数据的唯一性
2. 大大加快数据检索的速度
3. 加快数据排序，索引本身就是按照一定的顺序存储
4. 在进行连接（JOIN）操作或复杂的查询时，索引可以显著提高处理速度，减少数据库的负载

#### 主键和索引

总结：

1. 主键逻辑存在，相当于一本书的页码，不允许重复和NULL
2. 索引物理存在，相当于一本书的目录，可以重复

主键是数据库表中的一个列（或一组列），用于唯一标识表中的每一行记录。主键的要求是：

- 每个表只能有一个主键。
- 主键的值必须是唯一的，不允许重复。
- 主键列不能有空值（NULL）。

主键的主要目的是确保数据的完整性和唯一性，它是实体完整性的一部分。

索引是数据库表的一个结构，可以帮助快速检索表中的数据。索引可以创建在一个或多个列上，目的是加快查询速度和数据的访问。索引本身并不强制数据的唯一性或完整性（除非特别指定为唯一索引），索引可以有多个。

主键和索引的关系

- **自动索引**：在大多数数据库系统中，当你定义一个列为主键时，系统会自动在该列上创建一个唯一索引。因此**主键一定是唯一性索引，唯一性索引不一定是主键**。
- **功能区别**：**主键的主要功能是数据的唯一标识和完整性保障，而索引的主要功能是提高查询效率**。

总结来说，**主键确保记录的唯一性和完整性，而索引则主要用于提高数据访问的速度（减少磁盘I/O的次数）**。

#### Innodb为什么使用自增id作为主键

MySQL是一个关系型数据库管理系统，提供了多种存储引擎，**InnoDB是MySQL中的一种存储引擎，它负责数据的存储、索引和检索等操作**。

如果使用自增id作为主键，每次插入新的记录就会在当前索引节点的后续位置，一页写完就开辟新的页。

如果使用非自增主键（学号等），每次插入新纪录类似随机，会产生大量碎片，索引结构不够紧凑。

#### MyISAM和InnoDB实现B树索引方式的区别是什么

MyISAM也是MySQL的存储引擎，***MyISAM*类型的表强调的是性能，其执行数度比*InnoDB*类型更快，但是不提供事务支持，而*InnoDB*提供事务支持已经外部键等高级数据库功能**。

**MyISAM**

- **非聚集索引**：MyISAM 使用**非聚集索引**。在这种索引结构中，索引和数据是分开存储的。**索引项包含键值和一个指向数据记录的物理指针。**因此，即使找到了索引，还需要通过指针去数据文件中检索实际的数据。
- **全表扫描**：如果没有使用索引，MyISAM 需要进行全表扫描来查找数据。

**InnoDB**

- **聚集索引**：InnoDB 使用**聚集索引**。在这种结构中，**表数据实际上存储在索引的叶子页中。每个表都有一个主键索引，且数据按主键的顺序存储。如果表没有显式定义主键，InnoDB 会自动选择一个唯一列作为主键，如果没有唯一列，则会自动生成一个隐藏的行ID作为主键**。
- **辅助索引**：对于非主键索引，**InnoDB 创建的是辅助索引，其叶节点包含相应行的主键值而不是指针。这意味着使用辅助索引时，InnoDB 首先通过辅助索引查找到主键，然后再通过主键索引来访问实际数据**。

#### MySQL如何执行一条SQL的

<img src="http://oss.interviewguide.cn/img/202205220024265.png">

1. 客户端请求
2. 连接器验证用户身份，基于权限
3. 查询缓存，存在缓存则直接返回
4. 对sql进行词法分析和语法分析
5. 对执行的sql优化选择最优的执行方案
6. 操作引擎，返回结果
7. 存储引擎存储数据，提供读写接口

#### MySQL的内部构造

可以分为服务层和存储引擎：

1. 服务层：
   1. 连接器
   2. 查询缓存
   3. 分析器
   4. 优化器
   5. 执行器
2. 存储引擎层：插件式
   1. innodb：默认
   2. myisam
   3. memory

#### Drop、Delete和Truncate的异同点

Drop：

1. 删除整个表及其结构，不可逆不可回滚

Delete：

1. 用于删除一行或多行数据，可以搭配where
2. 只删除数据，不删除表结构
3. 事务安全，可以回滚
4. 相对较慢，没删除一行会记录日志

Truncate：

1. 快速清空表中所有数据，保留表结构
2. 比delete快，因为不逐行删除
3. 不可回滚

速度：drop>truncate>delete

#### MySQL优化，性能优化

1. 为搜索字段创建索引，索引可以提高搜索速度
2. 避免使用select *
3. 垂直分割表，将表中的列拆分为多个表，比如可以将频繁访问的列和不常访问的分开，提高性能
4. 选择正确的存储引擎：MyISAM适合读密集型场景，但不支持事务；InnoDB适合高并发和事务的应用

#### 脏读、幻读、丢弃修改和不可重复读

1. 脏读：一个事务读取了另一个事务未提交的数据，如果那个事务回滚，读取的数据是无效的。
2. 不可重复读：一个事务两次读取同一数据时，数据发生变化，这是因为另一个并发事务在两次读取之间更新了数据。
3. 幻读：和不可重复读类似，但涉及新插入或删除的记录，事务 A 根据某个条件查询数据，事务 B 在此条件下插入或删除了一些记录并提交，当事务 A 重新执行相同的查询时，会发现有额外的“幻影”记录出现或消失。
4. 丢弃修改：比如两个写事务同时某个数据递增，其中一个事务覆盖另一个事务导致结果不正确

脏读关注的是未提交数据的读取，不可重复读关注的是已提交的更新操作，而幻读则是关注于已提交的插入或删除操作。

#### 数据库隔离级别

1. 未提交读：事务发生了修改，即使没有提交，其它事务也可见。可能会**导致脏读、幻读或不可重复读**。
2. 提交读：一个事务的修改在提交之前都是不可见的。可以**阻止脏读、幻读或不可重复读仍可能发生**。
3. 重复读：对于一个记录读取多次记录是相同的，可以**阻止脏读、不可重复读，幻读仍可能发生**。
4. 可串行化读：并发情况下，和串行化的读取结果一致，**不会发生脏读、不可重复读以及幻读**。

<img src="https://cdn.jsdelivr.net/gh/peng-yq/Gallery/202406241229361.png"/>

InnoDB默认支持的隔离级别是重复读，但这个级别其采用**next-key lock**算法，也可以避免幻读的发生，**完全可以达到可串行化的隔离级别**。

**一般来说隔离级别越低，事务请求的锁就越少，大部分数据库系统的隔离级别是提交读，但innoDB默认使用重复读，并不会有性能损失。InnoDB在分布式事务的情况下一般会用到可串行化隔离级别**。

#### 数据库索引采用B+树的原因

B+树是一种自平衡的树数据结构，主要用于数据库和操作系统的数据存储和索引，是B树的一个变种。

1. B+树由一系列节点构成，分为内部节点和叶子节点，内部节点存储**键（key）**用于导航，叶子节点存储实际的数据
2. 叶子节点包含全部数据键及其对应的记录指针，节点通过指针串联成一个有序链表。

数据库使用B+树的优点：

1. 高效的搜索性能，B+树是一种多级索引，可以快速定位数据，搜索时间复杂度为O(logn)，即使大规模，查找效率也很高
2. 插入，删除节点，B+树自平衡
3. 数据都在叶子节点，叶子节点通过指针链接，进行范围查找十分高效
4. 减少磁盘I/O操作，叶子节点保持在同一层，存储在磁盘的同一块区域，减少磁盘寻道时间和页的读取次数

#### 视图和游标

视图：是一种虚拟的表，是一个表或多个表的行或列的子集，具有和物理表相同的功能

游标：用于在数据集中逐行遍历数据，使用场景包括处理复杂的逐行逻辑，或者在需要逐条处理或分析数据时进行操作。

#### MySQL中的事务回滚

回滚机制是通过回滚日志实现的，事务的所有操作都会记录到这个日志中，然后在对应的数据库中进行写入，事务被提交就无法回滚了，因此需要先写日志再写数据库。

#### InnoDB和MyISAM的区别

InnoDB：MySQL默认存储引擎，聚集索引、辅助索引，支持事务，支持在线热备份，支持外键和行级锁

MyISAM：非聚集型索引，适合读密集型场景，不支持事务，支持压缩表和空间数据索引，只支持表级锁

#### 数据库并发事务的问题

1. 脏读
2. 不可重复读
3. 幻读
4. 丢弃修改

#### 数据库悲观锁和乐观锁的原理和应用场景

1. 悲观锁：先获取锁，再进行业务操作，适合写操作多，冲突频繁的环境，比如银行账户处理，对数据的一致性要求很高
2. 乐观锁：先进行业务操作，实际更新数据时检查数据是否更新过，基于CAS机制通过版本号和时间戳实现，数据版本未变，事务提交成功，数据版本改变，事务回滚。适合读操作多，写操作少的场景，例如社交网络的数据展示等。

#### MySQL索引主要使用的两种数据结构

1. 哈希索引：使用哈希表，如果绝大多数需求为单条数据查询，选择哈希索引，查询性能最快，其余场景选择B+树索引
2. B+树索引：

#### 数据库为什么要分库、分表

1. 减轻单表负担、优化查询性能，

   1. 垂直分表：将不常用或大型数据字段分离出来，将频繁访问的放在一起
   2. 水平分表：按照某个规则（如ID范围、时间戳、哈希值等）将表中的行分配到多个相同结构的表中。适用于数据行数极大的表，如用户信息表、交易记录表等。

2. 分库：将数据分布到多个数据库，每个数据库可以部署到不同的服务器，通过负载均衡减小单一数据库压力，高可用和容错性

   