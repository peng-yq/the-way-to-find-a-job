### InnoDB 和 MyISAM 的B+树区别

InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：

- **InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身；**
- **MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址；**

这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。

![图片](https://cdn.xiaolincoding.com//mysql/other/00730eac527c21a4034f0f9ba0218aba.png)

如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：

![图片](https://cdn.xiaolincoding.com//mysql/other/f287701eba9bf6f32a2d09b013bb451b.png)

如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。

![图片](https://cdn.xiaolincoding.com//mysql/other/ef726d7287b854ea4862f7442d8012ec.png)

### 对索引使用左或者左右模糊匹配

当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

### 对索引使用函数

有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：

```sql
// name 为二级索引
select * from t_user where length(name)=6;
```

![图片](https://cdn.xiaolincoding.com//mysql/other/2525f7b7190eeb70323579e8d665eb94.png)

**因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据**。举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。

```sql
alter table t_user add key idx_name_length ((length(name)));
```

然后我再用下面这条查询语句，这时候就会走索引了。

![图片](https://cdn.xiaolincoding.com//mysql/other/56fc9a5a9b35d933f810e5213b3c8acb.png)

### 对索引进行表达式计算

在查询条件中对索引进行表达式计算，也是无法走索引的。比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：

```sql
explain select * from t_user where id + 1 = 10;
```

![图片](https://cdn.xiaolincoding.com//mysql/other/798ab1331d1d6dff026e262e788f1a28-20230309223731964.png)

但是，如果把查询语句的条件改成 where id = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。

![图片](https://cdn.xiaolincoding.com//mysql/other/96c3132ade7b161a5c2a3c051b337402.png)

**因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式**。有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 = 10 变成 id = 10 - 1。是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。

### 对索引隐式类型转换

**如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描**。我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。

![图片](https://cdn.xiaolincoding.com//mysql/other/e7aa91ce5e699ff0c6c357f6b1e70597.png)

然后我在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。

```text
select * from t_user where phone = 1300000001;
```

![图片](https://cdn.xiaolincoding.com//mysql/other/7be4dcbe00f15c8c583f20ffd67b772a.png)

**但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描**。我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。

```text
 explain select * from t_user where id = '1';
```

![图片](https://cdn.xiaolincoding.com//mysql/other/028df5ce4a42a6cf33524b2e1102c15d.png)

> 为什么第一个例子会导致索引失效，而第二例子不会呢？

要明白这个原因，**首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” > 9 的结果来知道MySQL 的数据类型转换规则是什么**：

- 如果规则是 MySQL 会将自动**「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；**
- 如果规则是 MySQL 会将自动**「数字」转换成「字符串」，就相当于 select "10" > "9"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么"10"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0**。

在 MySQL 中，执行的结果如下图：

![图片](https://cdn.xiaolincoding.com//mysql/other/25316fd06cadff4434f02391ef0b5c55.png)

上面的结果为 1，说明 **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：

```sql
//例子一的查询语句
select * from t_user where phone = 1300000001;
```

这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：

```sql
select * from t_user where CAST(phone AS signed int) = 1300000001;
```

可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的**。

例子二中的查询语句，我跟大家说了是会走索引扫描：

```sql
//例子二的查询语句
select * from t_user where id = "1";
```

这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：

```sql
select * from t_user where id = CAST("1" AS signed int);
```

**可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。**

### 联合索引非最左匹配

### WHERE 子句中的 OR

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

### MySQL 使用 like “%x“，索引一定会失效吗？

**使用左模糊匹配（like "%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)**。因为表的字段没有「非索引」字段，所以 `select *` 相当于 `select id,name`，然后**这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。**

再说一个相似，我们都知道联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树(type=index)，比如下图：

![图片](https://cdn.xiaolincoding.com//mysql/other/35d04bff09bb638727245c7f9aa95b5c.png)