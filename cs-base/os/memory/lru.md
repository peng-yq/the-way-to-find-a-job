传统的LRU算法存在以下2个问题，导致缓存命中率下降：

- 预读失效：操作系统在读磁盘中的数据时通常会多读一些数据至缓存中，如果这部分数据最后没访问到则会造成预读失效（传统的LRU算法只有一个链表，并且将页面直接放置链表头部，可能会淘汰一些热点数据）。
- 缓存污染：批量读数据时把一些热点数据换出了（LRU是最近最少使用，比如我批量读入一波数据到缓存中，这部分数据可能只用一次，但此时缓存不够了，需要换出一部分数据，此时就可能把一些热点数据换出了）

**Redis使用LFU算法（最不常使用）来进行缓存淘汰，从而减少缓存污染造成的影响（Redis没有预读机制）**。

> LFU相较于LRU，进行缓存淘汰时，会淘汰从加入缓存以来访问次数最低的页面。LFU的实现通过为每个页面维护一个计数器，可以通过一个或多个双向链表（每个链表保存不同计数的页面，当页面被访问时，将该页面转移到对应计数次数的链表）和哈希表（存储页面指针，方便快速查找）。每次淘汰时选择计数器最低的链表中的最旧项即可。
> LFU也是有缺点的，比如实现会比较复杂，以及启动偏差（刚加入的页面虽然计数很少，但未来可能会变得热门）

MySQL和Linux则通过改进LRU算法来减少预读失效和缓存污染带来的影响。

## Linux和MySQL中的缓存机制

### Linux

用户程序在第一次读取硬盘数据时，Linux系统会将硬盘数据进行缓存在系统的内存中（pagecache）。当用户程序再次读取这些数据时，先在缓存中查找，如果存在则直接返回，也就是缓存命中；否则对磁盘中的数据进行读取并进行缓存。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">

### MySQL

MySQL的数据是位于磁盘中的，如果每次都去磁盘中读取数据会很慢，因此MySQL提供了innoDB，innoDB使用一个位于内存中的缓存池（buffer pool）存储数据和索引。当读数据时首先查找buffer pool，如果存在即缓存命中直接读取，否则从磁盘中进行加载。写数据采用延迟写的机制，即写数据先在buffer pool中进行操作，等到适当的时机再批量写入磁盘。bufferpool中被修改但未写入磁盘的数据称为脏数据，innodb会定期将这些脏数据刷新进磁盘，保持一致性和同步。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png">

## LRU

但PageCache和buffer pool都是有大小限制的，当容量满时就需要淘汰掉页，如何设计淘汰机制显得很关键。比较常用的算法是LRU算法，即淘汰最近最少使用的页。LRU通过维护一个链表，链表头存储最近访问过的页面，而表尾存储最近最不常访问的页面。当用户访问数据时，如果缓存命中，则将面中页移动至链表头。如果没有面中则需要将磁盘中的数据读入缓存，同时将该页面置于链表头，如果此时容量已经满了，还需要淘汰掉链表最后一个页面。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/lru3.png">

**传统的LRU算法并未被MySQL和Linux所使用，因为传统的LRU算法会不可避免的出现预读失效和缓存污染两个问题**。

## 预读失效

这里再详细的描述以下预读机制，预读机制是为了减少磁盘读写次数提高磁盘I/O吞吐量，比如当用户程序读取磁盘上一个block（block是磁盘读取的最小单位，4KB）时，由于局部性原理，操作系统往往会多读取额外的几个block进入缓存中。这样用户程序访问到这部分数据时可以直接从缓存中读取，而不用再去读取磁盘了。

但预读机制会带来一些问题，传统的LRU算法中，预读的页会放入链表头部，如果这些页后续未被访问到，会大大降低缓存命中率。此外，如果缓存容量已满，预读的页还会淘汰链表尾部的旧页，如果这些旧页是热点数据，也会降低缓存命中率。

### Linux中对LRU算法的改进

区别于传统LRU算法只使用一个链表来维护页面，**Linux则使用2个链表（可以想成将之前的1个链表从中点分成了2个链表）**：

- 活跃LRU链表：存储最近最常使用的页
- 不活跃LRU链表：存储最近最不常使用的页，淘汰页面选择该链表尾部的页面

当操作系统预读一些页面后，如果这些页面未被使用，操作系统并不会将这些页面放置到活跃LRU链表的头部，而是选择不活跃的LRU链表头部。当这些页面被使用时，再将其放置LRU链表的头部，如果活跃LRU链表容器已满，则会将尾部的页面放置不活跃LRU链表头部。**这样即使预读的页一直未被读取，也会先热点数据淘汰**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BC%93%E5%AD%98/active_inactive_list2.drawio.png">

### MySQL对LRU算法的改进

MySQL的改进原理和Linux类似，只不过**MySQL仍采用一个链表，但将链表分成了2个区域，维护2对头尾指针。两个区域的比例默认是63：37**：

- young区域：对应活跃LRU链表
- old区域：对应不活跃LRU链表

预读的页先放至old区域的头部，如果被访问，则升级到young区域头部。如果一直未被访问，也会先于young区域中的热点数据被淘汰。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/lrutwo3.png">

## 缓存污染

缓存污染主要是针对批量读取数据而言的，当我们批量从磁盘中读取访问数据时（比如mysql从一个表中查询数据，即使结果集很小，但由于需要进行比对，也会读取访问大量数据），这些数据会被放置活跃LRU链表或young区域，如果此时缓存比较有限，就会导致热点数据被换出，后续访问这些热点数据时就会导致大量的磁盘I/O，性能下降。而缓存中的这些数据后续可能不会被用到，从而造成缓存污染。

### 如何避免缓存污染

**我们仔细分析一下导致缓存污染的根本原因是什么，当页面被访问一次，我们就将其放入了活跃LRU链表或者young区域，即使它们后续可能不被访问，也就是门槛太低了**。

**因此，只需要提高进入活跃LRU链表/young区域的门槛即可，Linux中当不活跃LRU链表中的页面被访问2次时，才将其升级。而MySQL不仅old区域的页面需要被访问2次才将其升级至young区域，还要两次访问间隔时间大于1s**。通过提高升级门槛，如果这些数据只被访问1次，则不会升级，也就不会替换掉热点数据，减少缓存污染带来的影响。




