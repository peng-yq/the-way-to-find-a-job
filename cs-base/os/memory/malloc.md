<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">

Linux中进程虚拟地址空间分布如上：

- 代码段
- 数据段
- bss段
- 堆段
- 文件映射段
- 栈段

其中堆段和文件映射段的内存是动态分配的，分别由malloc和mmap。

## malloc是如何分配内存的？

**malloc非系统调用，是一个c库函数，用于动态分配内存，malloc根据需要分配的内存大小，使用两种系统调用方法分配内存（取决于glibc中的定义）**：

- brk()系统调用从堆中分配内存（128KB以下）
- mmap()系统调用从文件映射区中分配内存（128KB以上）

brk()系统调用比较简单，通过移动堆顶指针获得分配的内存空间。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/brk%E7%94%B3%E8%AF%B7.png">

mmap()系统调用则是在文件映射段使用**私有匿名映射（私有：这部分内存只能由该进程所访问，匿名则是该部分内存与任何文件系统中的文件无关，不是通过文件映射分配，而是操作系统直接分配）**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmap%E7%94%B3%E8%AF%B7.png">

**malloc分配的内存为虚拟内存，如果这部分内存未被访问，操作系统不会为其在物理内存中进行分配；当访问这部分内存时，通过查找页表发现没有存在于物理内存中，产生缺页中断，为其进行物理内存分配**。

## malloc(1)会分配多大的内存

malloc(1)从语义上来说是申请1字节的内存，但操作系统会分配更大的内存，具体取决于内存管理器。

- 内存对齐 
- 内存管理的开销
- 内存碎片

> 内存对齐是将数据元素的地址安排在某些数值的整数倍，例如一个数据类型需要4字节对齐，其起止地址应该是4的倍数，也就是二进制中后两位为00
> 内存对齐可以提升性能和数据访问效率（时钟周期之类的）
> ```c++
> struct Example {
>    char a;        // 占用1字节
>    int b;         // 通常占用4字节
> };
> ```
> 上述数据结构为了对齐4字节，a和b之间会插入一些填充字节，结构体最后的大小可能是8字节，而非5字节。

## free释放完内存，会将内存还给操作系统吗

- 如果malloc是调用的brk()分配内存，free后这部分内存不会归还给操作系统，缓存在malloc的内存池中，留着下次用
- 如果malloc是调用的mmap()分配内存，free后这部分内存会直接归还给操作系统，内存得到释放

## 为什么不全部使用mmap来分配内存

mmap作为系统调用，用户在申请内存时需要陷入至内核态，状态转换需要开销。此外，mmap分配的内存free后直接归还给内存，因此第一次访问mmap分配的虚拟地址时，容易产生缺页中断。

而brk申请的内存在free后不会归还给内存，因此下次申请时可以直接从内存池中取出使用，减少系统调用次数和缺页中断次数。

## 为什么不全部使用brk来分配内存

brk只能在堆顶进行处理，也就是只能线性的增加或减少内存地址，对于内存块大小不一样的应用和非连续的内存，brk容易产生内存碎片。

mmap则支持非连续的内存分配，因此两者结合起来用，大一点的分配用mmap，小一点的用brk。

## free()的参数仅为一个地址，如何知道释放的内存大小

<img src="https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png">

分配的内存块左边便宜16字节是内存块的描述信息，包含内存块大小。