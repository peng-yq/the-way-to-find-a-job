物理内存满后，操作系统的一些方法：

1. 交换分区，LRU将一些长时间未使用的内存页面换出到硬盘中
2. 内存压缩，比如Windows任务管理器性能页面会有已压缩，通过压缩算法压缩包含大量重复信息和空闲空间的页面，将压缩的页面保存在内存的一个专有区域，这些页面被访问时再解压回来
3. 内存回收，回收缓存数据，分为后台内存回收和直接内存回收，一个是异步的，一个是同步的
4. 优化内存分配，比如延迟分配（也就是不到最后要用都不分配）
5. OOM

当进程访问虚拟地址，发生缺页中断，操作系统需要为其分配内存的流程如下：

<img src="https://cdn.xiaolincoding.com//mysql/other/2f61b0822b3c4a359f99770231981b07.png">

**当常规的内存回收策略比如后台内存回收和直接内存回收后，系统中仍然没有足够的内存进行分配时，操作系统会触发OOM killer来终止一些进程，防止系统因为内存耗尽而崩溃。OOM选择终止的进程需要考虑多个指标，比如内存使用量，运行时间和重要性等，需要最小化终止内存对系统的影响**。

## 哪些内存可以被回收

主要有2种内存可以被回收：

1. 文件页：包括操作系统缓存的磁盘数据（buffer）和缓存的文件数据（cache），因为这些数据下次再次需要时可以从磁盘中读取，因此可以被回收，**非脏页可以直接回收，脏页（进行了修改但还没写入磁盘中）需要写入磁盘后再回收**
2. 匿名页：前面在malloc的时候提到使用mmap分配的页是私有且匿名的，所谓匿名就是没有具体的载体，不同于映射的磁盘文件，这部分内存可能还会被使用，因此**回收时先swap置换到磁盘，再进行回收**

回收文件页和匿名页都是通过LRU算法，LRU算法通过维护两个链表，一个是活跃内存页链表，一个是非活跃内存页链表，越靠近链尾越不活跃，优先被回收。

```shell
worker2@k8s-worker2:~$ cat /proc/meminfo | grep -i active | sort
Active:           777716 kB
Active(anon):     422500 kB
Active(file):     355216 kB
Inactive:        2122224 kB
Inactive(anon):   262524 kB
Inactive(file):  1859700 kB
```

## 内存回收带来的性能影响

内存回收是会带来一些性能影响的，后台内存回收是异步的还好，直接内存回收是同步的，会导致阻塞，有性能损耗。此外，文件页回收中的脏页需要先写入磁盘，匿名页则是需要swap到磁盘，这两个都是有性能损耗的。

### 调整文件页和匿名页的回收倾向

匿名页肯定会写磁盘，而文件页中的干净页是可以直接回收的，下面的操作可以调整操作系统对这两种内存页的回收倾向。0~100，越大越倾向于回收匿名页。

```shell
worker2@k8s-worker2:~$ cat /proc/sys/vm/swappiness
60
```

### 尽早触发后台内存回收

<img src="https://cdn.xiaolincoding.com//mysql/other/166bc9f5b7c545d89f1e36ab8dd772cf.png">

**系统剩余内存处于内存压力大的区域，操作系统会开启后台内存回收；剩余内存处于内存基本耗尽的区域时，操作系统会开启直接内存回收**。因此可以调整阈值。

### NUMA价格下的内存回收策略

SMP架构指所有CPU都共用一个bus总线，比如访问内存，也称为一致性访问存储模型。

NUMA架构是将CPU进行分组，每个组称为一个node，包含多个CPU，每组有独立的资源，包括内存等。不同node通过互联模块总线进行通信，也就是说每个CPU都可以访问所有资源，但访问远端node的资源耗时更长。

在NUMA架构下，当某个Node内存不足时，系统可以从其他Node寻找空闲内存，也可以从本地内存中回收内存。

<img src="https://cdn.xiaolincoding.com//mysql/other/feec409868070d8cd79aecad2895b531.png">

具体选哪种模式，可以通过/proc/sys/vm/zone_reclaim_mode来控制。它支持以下几个选项：

- 0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；
- 1：只回收本地内存；
- 2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。
- 4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。

## 如何保护一个进程不被OOM杀掉

**当操作系统不得不使用OOM时，会通过算法计算出每个可以被杀掉的进程的分数，得分最高的会被杀掉。具体的计算过程就不说了，但可以设置进程的OOM校准值，/proc/pid/oom_score_adj，范围为-1000~1000，默认为0，也就是内存页面使用越多的越容易被杀掉。设置为-1000时计算所得的分数使得这个进程永远不会被杀死，例如一些系统程序sshd，而自己的业务程序不推荐这样设置**。