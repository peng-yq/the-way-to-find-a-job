## 文件系统的基本组成

文件系统负责计算机数据的持久化保存，文件系统管理的基本单位是文件，不同的文件系统对文件的管理组织方式不同。**文件系统中的每个文件包含两个数据结构，用于记录文件的元数据和目录层次结构**：

- **索引节点inode：inode用于记录文件的元数据信息，包含文件的inode编号、大小、访问权限、创建时间、修改时间和存储在磁盘的位置等。inode和文件一一对应，是inode的唯一标识，inode存储在磁盘中（为了加快速度，内存中也有inode缓存）**
- **目录项dentry：dentry包含文件的名字（是的，inode并不包含文件的名字），inode指针和其他目录项的关系，多个目录项关联起来组成了目录结构。与inode不同，目录项由内核维护，缓存在内存中**

> 为什么不将文件名字存储在inode中呢？
> 1. 分离文件名和文件元数据，使得硬链接的实现简单，可以通过多个目录项指向同一个inode，使一个inode（文件或目录）拥有多个名称
> 2. 节省空间和提高效率，如果将文件名存储在inode中，如果文件名变更则需要更大的inode或者重新分配inode（文件名字过长，inode大小一般固定），而目录项中的文件名字段长度不固定，这样修改文件名字只需对目录项中的文件名字段进行修改，无需影响inode
> 3. 优化性能，如果文件名存储在inode中，那根据文件名去查找文件时，需要遍历inode表。而将其存储在目录项中，则直接去其目录文件（存储文件名和inode的映射），访问对应的inode即可

由于inode唯一标识一个文件，而目录项包含文件名字。因此**inode和目录项是一对多的关系，一个文件可以有多个别名，硬链接就是为文件创建一个额外的目录项，目录项中文件名不同，但都指向相同的inode，实现可以使用不同文件名访问同一个文件**。

**目录也是文件，文件存储的是文件数据，而目录存储的是子目录和文件的信息（这些信息通常以目录项的形式存在）**。注意目录项不等于目录，目录是存储在磁盘中的一种文件，而目录项是缓存在内存中的，为了提高性能，操作系统会将读过的文件目录的目录项缓存在内存中。目录项既可以表示目录，也可以表示文件。

> 目录项和dentry的疑惑
>
> - 目录项：这是磁盘上的数据结构，存储在目录文件中。每个目录项包含至少两个基本信息：文件名和对应的inode编号。这些目录项是文件系统的一部分，它们持久化存储在磁盘上，确保了文件系统在关机后仍能保持其结构和数据。
> - dentry：这是操作系统内核中的一个缓存数据结构，存在于内存中。dentry用于存储文件系统中的目录项信息，以加速文件系统的查找和访问过程。dentry缓存文件名到inode的映射，以及目录结构之间的关系，从而使得文件名解析更快。
>
>
> 为什么说dentry只在内存中：
>
> - 性能优化：dentry设计为内存中的结构是为了性能优化。通过将常用的文件名和inode映射存储在快速的RAM中，系统可以迅速响应文件访问请求，减少磁盘I/O操作，从而显著提高效率。
> - 非持久化：dentry不需要持久化存储，因为它们仅为当前系统操作提供服务。系统关机或重启时，dentry缓存可以被重建，因为所有必要的信息（文件名和inode映射）已经安全地存储在磁盘上的目录项中。
>
>
> 结构体和存储方式
>
> - 磁盘结构体：目录项在磁盘上可能没有一个固定的“结构体”形式，它们的具体存储格式依赖于特定的文件系统实现（如ext4, NTFS等）。但通常，这些信息是按照一定格式序列化存储的。
> - 内存结构体：相比之下，dentry在内存中有明确的结构体定义，这些结构体由操作系统内核维护，用于快速访问和管理文件系统的目录树。

**磁盘读写的最小物理单位是扇区，扇区最早为512B，现代的可能为4KB。扇区很小，如果操作系统以扇区作为读写单位效率会很低，于是出现了块block（Linux中通常为4KB），块是文件系统的逻辑结构，一个block可以包含多个扇区**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png">

磁盘在格式化时，通常分为3个区域：

- 超级块：存储文件系统的信息，比如块个数、块大小和空闲空间等
- 索引节点区：存储索引节点
- 数据块区：存储具体的文件或目录数据

超级快在文件系统挂载进内存时加载进内存，索引节点区当文件被访问时加载进内存。

## 虚拟文件系统

**文件系统种类有很多，为了屏蔽不同文件系统的差异，操作系统在用户空间和文件系统之间也就是内核中引入了虚拟文件系统（VFS）。VFS屏蔽了底层文件系统工作的细节原理，提供了操作管理文件统一的数据结构和接口**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">

Linux根据存储的位置不同，将文件系统分为3类：

1. 磁盘文件系统：数据直接存储在磁盘中，比如ext2/3/4，XFS
2. 内存的文件系统，不存储在磁盘（不需要持久化），占用内存空间，比如/proc和/sys，反应系统的实时数据，动态生成
3. 网络文件系统：访问其他计算机的数据，比如NFS和SMB

**文件系统必须挂载到某个目录才能使用，比如Linux会把文件系统挂载到根目录**。

 ## 文件的使用

在编写代码时，写入一个文件的基本过程如下：

```c
fd = open(name, flag); # 打开文件
...
write(fd,...);         # 写数据
...
close(fd);             # 关闭文件
```

首先通过open()系统调用打开给定文件名的文件，并返回该文件的文件描述符；然后再使用write向该文件写入数据，参数为返回的文件描述符；最后通过close关闭文件描述符，避免资源泄露。操作系统会在进程的PCB中为其维护一个打开文件描述符表，用于跟踪进程打开的文件。操作系统在打开文件描述符表中维护着进程打开文件的状态和信息：

- 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；
- 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；
- 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；
- 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；

读文件和写文件的过程：

- 当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。
- 当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。

所以说，**文件系统的基本操作单位是数据块**。

## 文件的存储

文件数据的存储是在磁盘中，与数据在内存中的存储方式类似，文件数据在磁盘中的存储有以下2种方式：

- 连续地址空间存放
- 非连续地址空间存放：可分为链表方式和索引方式

### 连续地址空间存放

连续地址空间存放顾名思义是将文件数据存放在磁盘的连续块中。**这种方式比较高效，一次磁盘寻道即可读出文件全部数据，但需要提前知道文件的大小**，也就是需要在文件头（类似inode的东西，PS感觉这里说文件头名字不准确）中指明文件的起始块和大小。

**连续地址空间存放的缺点则是容易产生磁盘空间碎片和文件长度扩展难**。容易产生磁盘空间碎片则是由于不同文件数据存放都是连续并且大小不一致的，比如我文件A、文件B和文件C是相邻的，大小分别是300MB、200MB和300MB。文件B删除后，文件A和文件C之间空出200MB容量，若新文件大于300MB，则可能造成这部分磁盘空间浪费，造成空间碎片。文件长度扩展难就更好理解了，因为是连续空间存放，涉及到文件数据的移动。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87.png">

### 非连续地址空间存放

#### 链表

**链表方式的文件数据存储可以消除磁盘空间碎片和文件长度扩展难的问题，链表方式可分隐式链表和显式链表**。

**隐式链表方式，文件头需要记录文件开始块和结束块的位置，每个文件块中必须留出一个位置存储下一个文件块的指针，这样从链表头开始可以顺着指针访问文件数据。隐式链接的缺点具有链表的缺点，只能通过指针顺序访问数据块，不能直接访问。此外，隐式链接的稳定性差，可能会导致文件块中的指针数据丢失**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.png">

**而显式链接则是将文件块中的指针显式的存储在内存中的一个表中即FAT（文件分配表），文件分配表每一个表项表示一个磁盘块，表项中的内容为文件下一个磁盘块的位置或者特殊的结束标识（例如0xFFFFFFF）。通过查找文件目录项中的起始号并根据FAT表可以访问文件数据。FAT支持直接访问，这里的直接访问并不是数组那样，我们依然需要通过链表指针顺序查找，但是由于FAT表存储在内存中，我们在顺序查找到所需文件数据所在块时，再读取对应的磁盘即可，而隐式链接则需要依次顺序读盘。由于显式链接将块指针存储在内存中，FAT方案不适合大磁盘，大磁盘使得FAT表会占用大量的内存**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.png">

#### 索引

**索引方式通过为每个文件创建索引数据块（一个block），索引数据块中存储指向文件存储数据块的指针**。创建文件时，需要在其文件头中包含索引数据块的指针，在将文件数据写入磁盘块时，现在磁盘中为其进行分配，再在索引数据块中添加该块指针。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png">

索引方式存储具有**文件长度可以动态变化，不会产生磁盘空间碎片，支持顺序读写和随机读写**的有点，**缺点之一是存储索引带来的开销**，每一个文件都需要为其分配一个索引块。文件数据很小，仍然需要为其分配一个索引块造成空间浪费；如果文件数据很大，一个索引块存储不下，**则需要多个索引块，可以通过链表+索引或者索引+索引的方式解决**。

链表+索引：在索引块中留位置存放指向下一个索引块的指针。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.png">

索引+索引：在一个索引块中存放多个索引块指针。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.png">

### unix文件的存储方式

随机地址空间存储，链表地址空间存储和索引地址空间存储三种方式的优缺点：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png">

早期unix文件系统结合了上述3种方式的优缺点，**根据不同的文件大小使用不同的存储方式**：

- 如果存放文件所需的数据块小于10块，则采用直接查找的方式；
- 如果存放文件所需的数据块超过10块，则采用一级间接索引方式；
- 如果前面两种方式都不够存放大文件，则采用二级间接索引方式；
- 如果二级间接索引也不够存放大文件，这采用三级间接索引方式；

**上述方式则需要文件头使用13个指针**：

- 前面10个指针指向直接查找的10个数据块
- 第11个指针指向一级索引块
- 第12个指针指向二级索引块
- 第13个指针指向三级索引块

**上述方案用在Linux Ext2/3文件系统种，解决了大文件的存储，但对于大文件查找效率较低，Ext4对其进行了优化**。

## 空闲空间管理

前面所述的文件存储空间方式是针对已存储文件的，那对于未存储的文件应该怎么为其分配空闲的磁盘空间呢，包括3种方法：

1. 空闲表法
2. 空闲链表法
3. 位图法

### 空闲表法

空闲表法则是为磁盘中的所有空闲空间维护一个空闲表，每个表项为空闲块的起始块号和大小，这种方式适合连续地址空间存储，并且如果磁盘中有很多小的空闲空间（空闲表的表项存放的是连续空间），空闲表将会变得很大。搜索和删除空闲空间都需要遍历空闲表。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png">

### 空闲链表法

相交于空闲表法，空闲链表法使用指针保存下一个空闲块的位置，需要多大的空间就遍历链表取相应的数据块即可，添加则是将其添加到链表头，适合离散化数据存储，只需保留一个指向第一个空闲块的位置即可。空闲链表法简单但不能随机访问，此外每个块存储指针需要消耗一定的空间。

### 位图法

**空闲表法和空闲链表法都不适合大型文件系统，会使空闲表和空闲链表的空间变的很大**。

**而位图法通过二进制的一位来关联对应的数据块，为0表示数据块空闲，为1表示数据块占用，每个数据块都对应一个二进制位。除了空闲块的管理，Linux对于空闲inode的管理也使用位图**。

## 文件系统的结构

Linux通过位图来管理空闲块和空闲inode，如果只使用一个块来存储位图，只能管理很少的空间，因此Linux中将多个块联合在一起组成块组进行管理。

Linux Ext2文件系统结构如下：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9D%97%E7%BB%84.png">

最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：

- 超级块，包含的是文件系统的重要信息，比如inode总个数、块总个数、每个块组的inode个数、每个块组的块个数等等。
- 块组描述符，包含文件系统中各个块组的状态，比如块组中空闲块和inode的数目等，**每个块组都包含了文件系统中「所有块组的组描述符信息」**。
- 数据位图和inode位图， 用于表示块组中对应的数据块或 inode 是空闲的，还是被使用中。
- inode列表，包含了块组中所有的inode，inode用于保存文件系统中与各个文件和目录相关的所有元数据。
- 数据块，包含文件的有用数据。
  
**每个块组里有很多重复的信息，比如超级块和块组描述符表，这两个都是全局信息。如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的**。通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。不过，**Ext2的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组0、块组1 和其他ID可以表示为3、 5、7的幂的块组中**。

> 感觉快组描述符的同步是个问题

## 目录的存储

Linux中目录也是文件，普通文件存储的是文件的数据，而目录文件存储的则是目录下文件（普通文件和目录文件）的信息。目录可以通过vim打开，使用vim打开一个文件目录的内容如下：

<img src="https://cdn.jsdelivr.net/gh/peng-yq/Gallery/202404291713494.png">

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E5%93%88%E5%B8%8C%E8%A1%A8.png">

**但通过遍历目录文件中进行文件和目录名匹配效率会比较低，因此通过保存其哈希值进行匹配，但需要解决哈希冲突的问题。此外，为了避免频繁读写磁盘，操作系统会将使用过的目录文件缓存至内存中，加快速度**。

## 硬链接和软链接

在Linux系统中想要给一个文件或目录设置一个别名，使得可以通过这个别名来进行访问，可以通过**硬链接**和**软链接**实现。

**硬链接和普通文件类似，但其目录项中的inode编号和源文件一致，多个目录项中的inode一致指向同一个文件，实现硬链接。硬链接的文件属性、内容和源文件一致，只有当所有的硬链接和源目标文件都被删除时，系统才会彻底删除该文件。硬链接不支持跨文件系统，因为不同文件系统的inode数据结构和列表可能不同**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png">

**软链接相当于创建一个新的文件，不同于硬链接中目录项的inode和源文件一致，软链接目录项中的inode号与源文件不相同，软链接的文件内容为源文件的链接，并且软链接支持跨文件系统。源文件被删除时不影响软链接的存在，但指向的文件打不开**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E9%93%BE%E6%8E%A5.png">

## 文件I/O

### 缓冲和非缓冲I/O

根据**是否利用标准库缓冲，可把文件I/O分为缓冲I/O和非缓冲I/O**：

- 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。
- 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。

### 直接I/O和非直接I/O

根据**是否利用操作系统的缓存（page cache），可把文件I/O分为直接I/O和非直接I/O**：

- 直接I/O：不会将数据经过操作系统缓存，直接通过文件系统访问磁盘
- 非直接I/O：读操作时，将数据拷贝至操作系统缓存；写操作是先写入操作系统缓存，再写入磁盘

如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。

内核缓存中的数据在以下几种情况会被写入磁盘：

1. 调用write后，缓存中数据很多
2. 显式使用sync将内核缓存刷新到磁盘
3. 计算机已无物理内存，需要进行内存回收，会将缓存写入磁盘
4. 内核缓存的数据缓存时间超过某个阈值，缓存中的数据将被写入磁盘

### 阻塞与非阻塞I/O VS 同步与异步I/O

不多说了，前面总结过了。

将I/O分为两个过程的：

1. 数据准备的过程
2. 数据从内核空间拷贝到用户进程缓冲区的过程

阻塞I/O会阻塞在「过程 1 」和「过程 2」，而非阻塞I/O和基于非阻塞I/O的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步I/O。异步I/O则不同，「过程 1 」和「过程 2 都不会阻塞。