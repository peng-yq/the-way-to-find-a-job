使用锁的目的是为了保证共享资源在任意时刻只有一个线程访问。常见的锁包括：

- 互斥锁
- 自旋锁
- 读写锁
- 乐观锁
- 悲观锁

## 互斥锁和自旋锁

互斥锁和自旋锁是两种偏底层的锁，很多高级的锁都是由这两种锁实现的：

- 互斥锁：加锁失败后，会立即释放CPU，进入阻塞状态（例如c++11提供的mutex）
- 自旋锁：加锁失败后，会进入忙等状态，直到获取到锁

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/%E4%BA%92%E6%96%A5%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">

互斥锁中，进程尝试获取锁失败后会陷入内核态变为阻塞状态，等待锁可用时再由内核唤醒，从阻塞态变为就绪态，**会发生2次线程上下文切换**（线程的上下文切换主要是线程的私有资源，比如寄存器和私有数据等）。

自旋锁是通过CPU提供的CAS函数（Compare And Swap）（之前提到的test and set也差不多，都是原子指令/操作），**在用户态完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些**。

> CAS操作通常包含三个参数：
> 内存位置（Memory Location）：要操作的数据的内存地址。
> 预期值（Expected Value）：预期内存位置中的值。
> 新值（New Value）：如果内存位置的当前值与预期值匹配，则将其更新为此新值。
> 操作的步骤如下：
> 首先，CAS会检查目标内存位置的当前值是否与提供的预期值相匹配。
> 如果它们匹配，那么将内存位置的值更新为新值。
> 如果它们不匹配，操作失败，通常返回内存位置的当前值。

CAS实现自旋锁：设锁为变量lock，整数0表示锁是空闲状态，整数pid表示线程ID，那么CAS(lock, 0, pid)就表示自旋锁的加锁操作，CAS(lock, pid, 0)则表示解锁操作。忙等待状态可通过while实现。

**在单核CPU上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单CPU上无法使用，因为一个自旋的线程永远不会放弃CPU**。

- 在多核环境中，自旋锁可能更高效，因为它避免了频繁的线程上下文切换。但在单核环境中，频繁的自旋会导致CPU资源浪费，因为自旋的线程实际上没有做任何有用的工作。
- 互斥锁在几乎所有情况下都更适合单核处理器，因为它们通过使线程休眠来更好地管理有限的CPU资源。

## 读写锁

读写锁和读者-写者问题相关，读锁是共享锁，允许多个读者并发拥有读锁；写锁是独占锁，同一时刻只允许一个写者拥有，并且不允许写锁和读锁同时被拥有。**读写锁适合读多写少的场景**，读写锁可分为读优先锁和写优先锁。读优先锁和写优先锁都会产生饥饿问题。

读优先锁：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/%E8%AF%BB%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">

写优先锁：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/%E5%86%99%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">

公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现饥饿的现象。

**读写锁可以选择互斥锁或自旋锁实现**。

## 悲观锁和乐观锁

**悲观锁适合发生冲突概率很高的场景，悲观锁在获取共享资源前需要加锁，再对共享资源进行操作**。互斥锁、自旋锁和读写锁都属于悲观锁。

**乐观锁适合发生冲突概率较低的场景，乐观锁在获取共享资源前不需要加锁，直接对共享资源进行操作，操作完成验证这段时间是否发生冲突，如果发生冲突则放弃修改，否则修改完成**。CAS可以看作一种乐观锁。

乐观锁的例子：在线文档

我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。怎么样才算发生冲突？这里举个例子，比如用户A先在浏览器编辑文档，之后用户B在浏览器也打开了相同的文档进行编辑，但是用户B比用户A提交早，这一过程用户A是不知道的，当A提交修改完的内容时，那么A和B之间并行修改的地方就会发生冲突。

服务端要怎么验证是否冲突了呢？通常方案如下：

- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；
- 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。
- 实际上，我们常见的SVN和Git也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁**。

**不管是什么锁，加锁的粒度应该小，这样执行快**。