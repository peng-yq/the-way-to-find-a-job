## 竞争与协作

### 互斥

**竞争条件：在多进程/多线程情景，未对共享资源做适当同步，从而导致不确定性**。

**临界区：访问共享资源（内存，文件）的程序片段，为了避免不确定性，需要保证同一时刻只能有一个线程/进程访问该区域，也就是互斥**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/10-%E4%B8%B4%E7%95%8C%E5%8C%BA.jpg">

### 同步

多进程/线程场景下，除了互斥，还有同步。**同步指多线程/进程之间存在某种依赖关系，需要互通消息，例如A进程是生产者，B进程是消费者，B必须等A生产出来才能消费**。

同步就好比：操作A应在操作B之前执行，操作C必须在操作A和操作B都完成之后才能执行等；

互斥就好比：操作A和操作B不能在同一时刻执行；

## 互斥和同步的实现和使用

实现多线程/进程之间的协作，主要可通过锁和信号量实现（信号量相比锁更强大，可以方便的实现同步）：

- 锁：加锁和解锁
- 信号量：P，V操作

### 锁

锁可分为**忙等待锁**和**无忙等待锁**。

> 这里简单描述一下自旋锁的伪代码，定义一个锁：包含一个flag成员，lock方法和unlock方法（当然还有构造方法之类的）
> lock和unlock都是原子操作，比如test and set，lock通过一个while循环判断锁是否有其他线程持有，如果没有则立刻退出while循环，并设置flag值使得其他线程尝试获取锁一直忙等（while）；unlock则是将flag设置为初始值
> 需要注意的是这种简单的是实现方式可能会出现A线程持有锁，而B线程释放锁的过程；一般来说锁的释放只能持有锁的线程进行，需要程序员的编程规范，或者记录持有锁的线程

- 忙等待锁：也称为自旋锁，如果获取不到锁，就一直等待。忙等待锁的简易实现可见代码，需要使用原子操作（要么都做，要么多不做），避免多个线程同时改变锁状态。
- 无忙等待锁：获取不到锁不用自旋。

> 无忙等待锁，增加了一个队列用于存储阻塞的需要获取锁的线程，lock时若获取不到锁就将该线程添加至队列中，unlock再把队头的队列移出

### 信号量

> 信号量的伪代码实现和无忙等待锁有一些类似，一个成员用于表示资源数量（也就是支持多少个线程同时使用），一个队列用于存储阻塞的需要使用资源的线程，p操作将信号量-1，如果<0就将该线程移入队列；v操作将信号量+1，如果<=0，从队列中移出一个线程，将其唤醒，并将资源转交给它

1来互斥，0来同步就不再赘述了。

### 生产者和消费者问题

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/20-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.jpg">

生产者/消费者问题描述：

1. 缓冲区大小是有限的
2. 生产者生产数据放入缓冲区中
3. 消费者从缓冲区中取出数据进行处理
4. 同一时刻生产者和消费者只能有一个访问缓冲区

从上述描述看，需要进行互斥和同步：互斥则是对临界区缓冲区的访问控制；同步则是缓冲区为空时，消费者需要等待生产者生产，相反若缓冲区满，生产者需要等消费者消费才能继续生产。

代码中是使用锁和条件变量来解决生产者和消费者问题，如果纯用信号量来解决描述如下：

> 定义3个信号量，一个用于访问缓冲区，初始值为1；一个用于消费者消耗资源，初始值为0；一个用于生产者查询缓冲区空位，初始值为缓冲区大小
> 生产者步骤为：首先对访问缓冲区的信号量进行P操作实现互斥，再对缓冲区空位的信号量进行P操作，再对消耗资源的信号量进行V操作，生产完一个就对访问缓冲区的信号量V操作，让消费者可以消费
> 消费者步骤为：首先对访问缓冲区的信号量进行P操作实现互斥，对消耗资源的信号量进行P操作，再对缓冲区空位的信号量进行V操作，生产完一个就对访问缓冲区的信号量V操作，让消费者可以消费

## 经典同步问题

### 哲学家就餐问题

哲学家就餐问题由迪杰斯特拉提出：

- 环境设置：五位哲学家围坐在一张圆桌周围，每位哲学家在桌子上有一盘意面。桌子中间有一碗无限供应的意大利面。
- 资源：每位哲学家的左右两边各放有一支筷子（总共五支筷子）。
- 行为：哲学家有两种行为，一是思考，二是就餐。思考时不需要任何资源，但就餐时需要同时拿起左右两边的筷子。
- 挑战：每位哲学家拿筷子的顺序不一定，可能会导致所有哲学家都拿着左边的筷子等待右边的筷子被释放，从而造成死锁。

方案1：由于每根筷子同一时刻只能被一个哲学家拿起，因此是互斥量，将每根筷子设置为信号量，初始值为1。哲学家在就餐之前需要拿起左边的和右边的筷子，也就是进行P操作，就餐完再V操作释放筷子。

**但此方案会出现死锁，当所有哲学家都拿着左边的筷子或者拿着右边的筷子，等待另一边的筷子时**。

方案2：上述现象出现主要是因为拿起左右两根筷子的动作不是原子操作，因此方案2选择在拿起左右两根筷子是加锁（或者使用信号量）。

**但此方案同一时间只能有1个哲学家就餐，因为锁只有1个**。

方案3：避免使用锁同时避免所有哲学家都先拿起同一边的筷子，让偶数位的哲学家先拿左边筷子再拿右边筷子；奇数位哲学家先拿右边筷子再拿左边筷子。

**此方案可以满足同一时刻2位哲学家就餐，并且不会死锁**。

方案4：把哲学家设置为信号量（初始值为0，用于同步），此外，同一时刻只能对一个哲学家进行操作，因此需要使用一个互斥量。定义3个状态（思考，饥饿，就餐），只有当左右两边的哲学家都没就餐并且当前哲学家为饥饿状态时，设置其状态为进餐，并使用V操作唤醒该哲学家表示可以进餐了。哲学家需要经历思考，拿起筷子，就餐，放下筷子四个步骤。拿起筷子的过程中，如果成功获取两边筷子，会使用v操作将该哲学家信号量+1，然后再进行P操作-1，执行后续步骤，否则在P操作时被阻塞。放下筷子时，需要通知左右两边的哲学家可以进餐。比较复杂。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg">

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/31-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B-%E5%9B%BE%E8%A7%A3.jpg">

**「哲学家进餐问题」对于互斥访问有限的竞争问题（如 I/O 设备）一类的建模过程十分有用**。

### 读者-写者问题

**读者-写者问题为数据库访问构建了一个模型**：

- 读读：允许
- 读写：互斥，只有在没人写的情况下才能读
- 写写：互斥，不能同时写

方案1：读者优先方案，有读者在读，后续读者可以进入，而写者只有在没有读者的情况下写。并且只要有读者读就会立刻阻塞写者

- 1个记录当前读者数量的全局变量，初始为0
- 1个保证修改读者数量的全局变量互斥的信号量，初始为1
- 写者的互斥量
- 有读者读，并且此时全局变量为0时（避免重复P操作，仅需一次即可避免写者写），对写者互斥量进行P操作，阻塞写者
- 当前没有读者读时，对写者全局变量进行V操作，写者可写

方案2：写者优先方案，只要有写者写（第一个写者写需要等所有读者都读完了才能开始写），后续写者可以进入，但同一时刻只能一个写者写，而读者只有在没有写者的情况下写；读者操作和前面方案一样

（我怎么感觉这个也不算写者优先吧，毕竟读者一直读的话，写者也会饿死）

- 增加了一个记录写者数量的全局变量和一个互斥量来实现操作这个全局变量互斥

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/33-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg">

方案3：公平策略，相较于方案1，只需增加一个flag信号量实现互斥，避免只要有读者读就一直进入的权限。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg">
