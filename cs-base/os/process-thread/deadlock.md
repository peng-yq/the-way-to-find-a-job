## 死锁

构成死锁需**同时满足的4个条件**：

- 互斥条件
- 持有并等待
- 不可剥夺
- 环路等待

通过一个例子来说明上述4个条件，进程A需要资源1和资源2才能完成任务，而进程B也需要资源1和资源2才能完成任务；若此时进程A持有资源1，需要资源2，进程B持有资源2，需要资源1，A和B构成死锁。

**互斥条件**：资源1和资源2在同一时刻都只能由一个进程获取
**持有并等待**：进程A持有资源1，等待资源2，不完成任务前不退出；进程B同理
**不可剥夺**：资源1在进程A完成前不可剥夺
**环路等待**：进程A和进程B构成环路

## 利用工具排查死锁问题

排查死锁可以通过代码审查，C/C++可以使用GDB的调试功能，你可以在运行时检查线程的状态和锁的持有情况。虽然它不自动检测死锁，但你可以手动查看锁的持有者和等待这些锁的线程。使用info threads查看所有线程，thread <n>切换到特定线程，info lock查看锁的状态。

## 避免死锁问题的产生

避免死锁问题的产生，只需要破坏上面的4个条件之一即可，最常用的是使用**资源有序分配来破坏环路等待条件**。也就是进程A和进程B都先获取资源1再获取资源2。

## 银行家算法

银行家算法（Banker's Algorithm）是一种避免死锁和确保系统资源分配安全性的算法，由Dijkstra提出。这种算法通过模拟银行家发放贷款的方式来处理多个进程请求有限资源的问题。银行家在贷款时需要确保即使在最坏的情况下也能够收回贷款，类似地，银行家算法确保即使在最坏的情况下系统也不会进入死锁状态。

银行家算法的基本概念：

- 最大需求（Max）：每个进程可能请求的最大资源数量。
- 分配（Allocation）：当前每个进程已被分配的资源数量。
- 需求（Need）：每个进程还需要多少资源才能完成。计算公式为 Need[i] = Max[i] - Allocation[i]。
- 可用（Available）：系统中当前可用的资源数量。

银行家算法的工作流程：

1. 初始化资源：系统启动时，定义每种资源的总量。
2. 进程请求资源：进程提出资源请求。
3. 资源分配尝试：系统尝试预分配资源给请求进程，并进入安全性算法检查。
4. 安全性算法：系统检查是否存在至少一条使所有进程顺序结束的安全序列。如果存在，预分配资源变为正式分配。
5. 进程释放资源：进程完成后释放资源，系统将这些资源标记为可用。
6. 重复以上步骤：继续响应新的资源请求。

银行家算法的例子：

假设有两种资源类型A和B，可用数量分别为10和5。有三个进程P1、P2、P3，各自的最大需求和当前分配如下表：

| 进程 | 最大需求A | 最大需求B | 已分配A | 已分配B |
| ---- | --------- | --------- | ------- | ------- |
| P1   | 7         | 5         | 3       | 2       |
| P2   | 3         | 2         | 2       | 1       |
| P3   | 9         | 0         | 2       | 0       |


计算需求和可用资源：

1. 需求P1 = (7-3, 5-2) = (4, 3)
2. 需求P2 = (3-2, 2-1) = (1, 1)
3. 需求P3 = (9-2, 0-0) = (7, 0)
4. 可用资源 = 总资源 - 已分配资源 = (10-7, 5-3) = (3, 2)

安全性检查：

假设P2请求(1, 1)，系统尝试分配后：

1. 分配给P2 = (3, 2)

2. 可用资源 = (3-1, 2-1) = (2, 1)
3. 此时，系统检查安全性。P2的需求已被满足，可以完成执行并释放资源。释放后系统可用资源为(5, 3)。这足以满足P1或P3的剩余需求。因此，存在安全序列[P2, P1, P3]，这次资源请求是安全的。

**银行家算法通过预防性地检查资源分配后是否存在一个安全的完成序列，从而避免系统进入死锁状态。这种方法虽然可以保证系统的安全性，但在实际操作中可能因为其算法复杂度和资源使用效率较低而不被广泛使用**。