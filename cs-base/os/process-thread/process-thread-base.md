## 进程

### 进程的状态

一个进程在活动期间至少拥有3种基本状态：运行状态，就绪状态和阻塞状态：

1. 运行状态：该进程正在占用CPU，或者说CPU正在执行该进程
2. 就绪状态：该进程可以运行（比如数据已经准备完毕），等待操作系统分配时间片调度，也就是等待CPU执行
3. 阻塞状态：该进程正在等待某一事件（例如输入输出的完成）而暂时停止运行，此时赋予其CPU控制权，也无法运行

此外，进程还拥有另外2种基本状态：创建状态和结束状态，对应进程正在被创建的过程中以及运行完成或发生错误而结束的状态。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg">

进程不同状态的变更：

- NULL -> 创建状态：一个新进程被创建时的第一个状态；
- 创建状态 -> 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- 就绪态 -> 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- 运行状态 -> 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- 运行状态 -> 就绪状态：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- 运行状态 -> 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- 阻塞状态 -> 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

处于阻塞状态的进程会占用物理内存资源，如果拥有大量被阻塞的进程，就会造成物理内存资源浪费。在虚拟内存管理的操作系统中，通常会把处于阻塞状态的进程的物理内存空间换出到硬盘，等到再次需要时，再换进物理内存空间。此时进程位于硬盘中，没有占用实际的物理内存空间，位于挂起状态。挂起状态可分为阻塞挂起状态和就绪挂起状态。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/9-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA.jpg">

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg">

进程除了因为物理内存空间不够被换出到硬盘，从而处于挂起状态外，还可能因为sleep或ctrl+z等操作挂起一个进程。

### 进程的控制结构

PCB（Process Control Block，进程控制块）是操作系统中用于存储有关进程的信息的数据结构，是操作系统进行进程管理和调度的核心数据结构，它包含了操作系统需要的所有信息，以便能够管理进程。task_struct是Linux操作系统中实现PCB功能的具体结构。PCB也是进程存在的唯一标识。

PCB中的内容包括：

- 进程状态：如运行、就绪、阻塞等。
- 进程标识符（PID）：唯一标识一个进程。
- 程序计数器：指示进程下一条要执行的指令的位置。
- CPU 寄存器：存储进程的当前工作状态。
- CPU 调度信息：优先级、调度队列指针等。
- 内存管理信息：页表、段表等。
- 会计信息：CPU 使用时间、实际使用时间、进程创建和终止的时间等。
- I/O 状态信息：分配给进程的 I/O 设备列表、打开文件列表等。

操作系统通过链表的方式将处于相同状态的进程（PCB）链接在一起，形成不同的队列，例如阻塞队列，就绪队列等。单对于单核CPU而言，在某个时间只能运行一个进程。除了链表的方式，还可以通过索引，但链表创建和删除节点更加灵活。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg">

### 进程的控制

**进程的创建**：进程可以创建另一个进程，子进程继承父进程所拥有的资源。

1. 申请一个空白PCB，并填入相关的信息，例如PID等
2. 为新进程分配运行所需的资源
3. 放入就绪队列，等待被os调度

**进程的终止**：进程终止大致可分为正常结束，异常结束和外界干预（信号kill）。子进程被终止时会将其资源归还给父进程，而父进程终止时，子进程将成为孤儿进程，交由1号进程（init进程，所有进程的祖先）处理（比如释放资源等）。

1. 查找需要被终止的PCB，若进程处于运行状态，立刻终止其执行，并将CPU资源分配给其他进程
2. 如果该进程有子进程，则将子进程交由1号进程处理
3. 释放资源
4. 从对应的队列删除

**进程的阻塞**：当进程需要等待某事件完成时，可以调用阻塞语句置为阻塞状态。当进程位于阻塞状态时，只能由另外一个进程唤醒。

1. 查找需要阻塞的PCB，如果当前进程位于运行状态，需要保存其上下文，并置为阻塞状态，停止运行
2. 添加至阻塞队列

**进程的唤醒**：位于阻塞状态的进程只能由其他进程唤醒，并且此时所等待的事件已经完成。

1. 在阻塞队列中查找需要唤醒的PCB
2. 将其状态置为就绪状态，并放入就绪队列

### 进程的上下文切换

一个进程切换到另外一个进程，称为进程的上下文切换。CPU运行进程时需要知道代码（指令）从哪里加载以及执行到哪里，也就是需要设置**CPU寄存器和程序计数器（PC），这两者都是CPU内部的硬件组件，被称为CPU上下文**。CPU上下文切换也就是将前一个任务的CPU寄存器和程序计数器保存起来，然后加载新任务的上下文至CPU寄存器和程序计数器。

- CPU寄存器：CPU寄存器是小的、快速的存储设备，位于CPU内部，用于临时存储指令、数据和地址等信息。寄存器的存取速度非常快，远快于主内存。
- PC：程序计数器，也称为指令指针，是一个特殊的寄存器，用于存储下一条要执行的指令的内存地址。

进程的上下文切换包括用户空间的信息和内核空间的信息，当发生进程上下文切换时，内核会将当前进程的上下文信息保存在PCB中，然后从另一个进程的PCB中取出上下文信息，并恢复至CPU中，继续执行。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg">

## 线程

为什么需要线程？

- 多进程之前的通信和数据共享
- 创建，终止，进程切换和维护进程开销大

进程的优点：

- 轻量
- 并发
- 一个进程可以多个线程
- 共享进程资源

进程的缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）

一些补充：

- 线程同样拥有运行、就绪和阻塞等状态
- 线程能减少并发执行的时空开销（位于同一地址空间，不需要换页表，只需要切换私有数据，例如寄存器和堆栈）
- **线程是os调度的基本单位**

### 线程的实现

线程的实现方式可分为3种：

1. 用户线程：用户空间实现的线程，非内核管理，使用用户态的线程库创建
2. 内核线程：内核空间实现的线程，内核管理
3. 轻量级进程：在内核中来支持用户线程

用户线程是基于用户态的线程管理库来实现的，线程控制块（Thread Control Block, TCB）也是在库里面来实现的，对于操作系统而言是看不到这个TCB的，它只能看到整个进程的PCB。所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。(多对一)

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg">

内核线程是由操作系统管理的，线程对应的TCB自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。（一对一）

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg">

轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个LWP，每个LWP是跟内核线程一对一映射的，也就是LWP都是由一个内核线程支持，而且LWP是由内核管理并像普通进程一样被调度。在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而LWP代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以LWP也不带有这样的信息。

## 调度

详细内容看[博客——现代操作系统原理与实现-操作系统调度](https://peng-yq.github.io/2023/06/19/scheduling-real/)。

### 调度原则

- CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- 周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
- 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

### 调度算法

最高优先级（HPF）调度算法：银行就对客户分等级，分为普通客户、VIP 客户、SVIP 客户。只要高优先级的客户一来，就第一时间处理这个客户，这就是最高优先级（HPF）调度算法。但依然也会有极端的问题，万一当天来的全是高级客户，那普通客户不是没有被服务的机会，不把普通客户当人是吗？那我们把优先级改成动态的，如果客户办理业务时间增加，则降低其优先级，如果客户等待时间增加，则升高其优先级。

多级反馈队列（MFQ）调度算法：它是时间片轮转算法和优先级算法的综合和发展。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/34-%E9%93%B6%E8%A1%8C-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88.jpg">

- 银行设置了多个排队（就绪）队列，每个队列都有不同的优先级，各个队列优先级从高到低，同时每个队列执行时间片的长度也不同，优先级越高的时间片越短。
- 新客户（进程）来了，先进入第一级队列的末尾，按先来先服务原则排队等待被叫号（运行）。如果时间片用完客户的业务还没办理完成，则让客户进入到下一级队列的末尾，以此类推，直至客户业务办理完成。
- 当第一级队列没人排队时，就会叫号二级队列的客户。如果客户办理业务过程中，有新的客户加入到较高优先级的队列，那么此时办理中的客户需要停止办理，回到原队列的末尾等待再次叫号，因为要把窗口让给刚进入较高优先级队列的客户。

可以发现，对于要办理短业务的客户来说，可以很快的轮到并解决。对于要办理长业务的客户，一下子解决不了，就可以放到下一个队列，虽然等待的时间稍微变长了，但是轮到自己的办理时间也变长了，也可以接受，不会造成极端的现象。

