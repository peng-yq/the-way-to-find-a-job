#### 在main执行之前和之后执行的代码可能是什么

main之前主要是初始化系统相关资源：

- 栈指针
- 静态变量和全局变量（.data段内容）
- 将未初始化的全局变量赋初值，比如int为0，bool为false，指针为nil（.bss段内容）
- 全局对象初始化，构造函数
- 将main函数的参数，argc，argv传递给main函数，正式执行main函数
- \_attribute\_((constructor))

main函数执行之后：

- 全局对象的析构函数
- atexit注册一个函数，会在main之后执行
- \_attribute\_((destructor))

#### 结构体内存对齐

- 结构体成员按照生命顺序存储，第一个成员地址就是结构体地址
- 未特殊指明，结构体按size最大的成员对齐（整个结构体的大小需要是其整数倍）

c++11后引入alignas关键字指定结构体的对齐方式，alignof关键字计算类型的对齐方式。alignas可能会失效，比如小于最小自然对齐单位。

自然对齐：

- `uint8_t` 类型通常只需要1字节对齐，因为它只占用1字节。
- `uint16_t` 类型通常需要2字节对齐，这意味着它的地址应该是2的倍数。
- `uint32_t` 和更大的类型，如 `uint64_t`，则可能需要更大的对齐，通常是4字节或8字节。

```c++
// alignas 生效的情况

struct Info {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl;   // 6  2 + 2 + 2
std::cout << alignof(Info) << std::endl;  // 2

struct alignas(4) Info2 {
  uint8_t a; // 自然对齐是1字节，但是b的开始地址需要满足是2字节的倍数，因此a后面补充1字节
  uint16_t b; // 按照2字节自然对齐
  uint8_t c; // 自然对齐是1字节，但是为了满足结构体按4字节对齐，c后面补充3字节
};

std::cout << sizeof(Info2) << std::endl;   // 8  2 + 2 + 2 + 2
std::cout << alignof(Info2) << std::endl;  // 4
```

#### 指针和引用的区别

- 指针是一个变量，存储的是地址；引用和原变量实质是一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为空并且定义时必须初始化
- sizeof指针是指针大小，sizeof引用是引用所指变量大小

#### 传递参数时，什么时候使用指针，什么时候使用引用

- 使用类对象作为参数传递的时候使用引用，这是C++类对象传递的标准
- 参数是可选的，即允许不传递任何对象，使用指针更好
- 动态分配的对象，通常使用指针

#### 堆和栈的区别

- 栈由系统自动分配，速度快，不会有碎片
- 堆由程序员手动申请和释放，速度慢，会有碎片
- 堆向上，向高地址方向增长
- 栈向下，向低地址方向增长
- 堆是不连续的内存区域，大小受限于计算机系统中有效的虚拟内存；栈是连续的，严格按照函数调用的顺序进行。每当一个函数调用发生，一个新的栈帧就会被压入栈顶；函数返回时，栈帧被弹出。大小是操作系统预定好的

#### 栈更快还是堆更快

- 栈更快，有操作系统底层的支持，有专门的寄存器存放，有专门的指令入栈出栈
- 堆的操作有C++函数库提供，并且需要算法计算合适大小的内存，获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存。

#### 区别以下指针类型

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- 第一个表示一个int\*类型的指针数组，大小为10，每个元素都是int\*
- 第二个表示一个指向int[10]的指针p
- 第三个表示函数名为p，参数是int，返回值是int\*
- 第四个表示函数指针，该指针指向的函数参数是int，返回值是int

#### new/delete与malloc/free的异同

- 两者都可以用于内存的动态申请和释放
- 前者是C++运算符，后者是C/C++语言标准函数
- new是类型安全的，会返回正确的类型指针，不允许隐式类型转换，比如`int *p = new float[2]; // 编译错误`
- malloc返回的是void\*，需要强制转换为适当类型
- new会自动调用类型的构造函数，delete会调用析构函数；malloc和free则不会
- new在无法分配内存会抛出异常；malloc会返回nullptr

#### new和delete如何实现

- new：调用operator new的标准库函数，分配足够大内存，运行该类型的构造函数并初始化，返回分配构造好的对象的指针
- delete：调用指向对象的析构函数，调用operator delete的标准库函数释放内存

#### 为什么还需要有new/delete，直接malloc/free不好吗

malloc和delete不能指向构造函数和析构函数，非基本数据类型通常需要

#### 被free的内存是立即返还给操作系统吗

不是，会使用双链表保存起来，下一次申请内存时会从这些内存中寻找合适的返回，避免频繁的系统调用，同时对小内存进行合并，避免过多的内存碎片。

为什么用双链表：

- 双向遍历
- 方便合并
- 快速插入和删除

#### 宏定义和函数的区别

- 宏在预处理阶段完成替换，被替换的文本参与编译，等于直接插入代码。无需函数调用，执行起来更快
- 函数调用需要跳转到具体函数，需要更多开销
- 宏定义不需要在最后加分号

#### 宏定义和typedef

- 宏主要定义复杂书写内容和常量
- typedef主要定义类型别名
- 宏不需要最后加分号；typedef需要

#### 变量声明和定义区别

- 声明只是把变量的声明位置和类型提供给编译器，不分配内存空间
- 定义需要在定义的地方为其分配存储空间
- 相同变量可以在多处声明（外部变量extern），定义只能在一处

#### strlen和sizeof

- sizeof是运算符，strlen是库函数
- sizeof函数可以是任何数据的类型或数据；strlen只能说字符指针，并且以'\0'结尾

```c++
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```

#### 一个指针多少字节

看机器位数，64位/8字节，32位/4字节

#### 常量指针和指针常量

- 常量指针：这个指针是场景，也就是地址不能改变，必须初始化，const在\*后面，比如int \* const p
- 指针常量：指针指向的值是常量，const在\*前面，比如int const \*p或const int \*p

#### a和&a有什么区别

```c++
int a[10];
int (*p)[10] = &a;
```

a是数组名，也是数组首元素地址，+1表示地址加上一个int类型大小，\*(a + 1)为a[1]

&a是数组的指针，类型为int (\*)[10]，+1表示数组首地址+加上整个数组的便宜

#### C++和python区别

- C++是编译型语言，需要对特定平台进行编译，Python是脚本语言，解释执行，更方便跨平台，C++效率更高

#### C++和C的区别

C++面向对象