#### C++中的组合，相比继承有什么优点

继承是is-A，组合是has-A

优点：

1. 可以隐藏类的实现系列，只能通过成员类来访问对应类的功能，无需了解其实现
2. 耦合度低，继承中基类的某个属性和方法改变，派生类需要修改
3. 过深的继承可能会难以维护
4. 更好的代码复用

#### 函数指针

函数指针是指一个指针指向一个由特定参数列表和返回值的函数类型，比如下面的函数指针pf，指向函数列表为两个const int&参数并且返回值是int的函数，注意括号是必须的：

```c++
int (*pf) (const int&, const int&);
```

可以将函数指针作为参数传递给函数，比如实现回调函数。

#### 内存对齐及其原因

1. 分配内存的顺序是声明的顺序
2. 每个变量相较于起始位置偏移量必须是其类型大小的整数倍，如果不是则需要补齐即内存对齐
3. 整个结构体大小默认是变量类型大小最大的整数倍

#### 结构体变量比较是否相等

重载“==”操作符

#### 函数调用过程栈的变化，返回值和参数变量哪个先入栈

1. **参数入栈**：在大多数调用约定中，调用者（caller）将参数按顺序（从右到左）。
2. **调用指令执行**：执行 CALL 指令，这时会将返回地址（即调用指令之后的下一条指令的地址）压入栈中。这个返回地址用于在函数执行完后跳回到调用者的代码。
3. **栈帧设置**：被调用的函数（callee）可能会创建自己的栈帧，用于存储局部变量、保存寄存器状态等。这一步骤通常包括移动栈指针来为局部变量腾出空间。
4. **函数执行**：函数体内的代码执行，使用栈上的参数和局部变量。
5. **返回值处理**：函数的返回值通常存放在寄存器中，或者通过栈传递（对于较大的数据类型，如大的结构体）。
6. **栈帧清理**：在函数返回前，需要清理局部变量，并将栈指针恢复到调用前的状态。
7. **返回到调用点**：通过 RET 指令使用之前压入栈的返回地址跳回到调用者的代码。

#### define、const、typedef、inline

通常define定义常量，并且不带类型，只在预处理阶段进行替换

const定义带类型的常量，在编译、链接过程中起作用，更加安全，会进行类型检查，推荐

typedef通常定义类型的别名，在编译阶段有效，做类型检查

inline是函数，也是替换，但在编译阶段起作用，有类型检查，更安全

#### printf的原理

函数调用压栈，参数从右到左入栈，出栈相反

#### 模板类为什么都是放在一个h文件中

普通类分布在头文件和源文件

1. **编译器实例化**：模板类或函数的代码在编译时需要根据具体的类型进行实例化。编译器必须在编译时看到模板定义的完整内容，以生成对应特定类型的实例化代码。
2. **链接问题**：如果模板定义放在源文件中，每个源文件编译时只会实例化它所用到的模板类型。这会导致在其他源文件中使用相同模板但不同类型时，因为缺乏必要的模板实例化代码而无法链接。
3. **避免重复实例化**：将模板定义放在头文件中，每次包含这个头文件的时候，相关的模板定义就会在该编译单元中可见，从而允许编译器为所需的具体类型生成模板实例。这样做确保了每种类型的模板实例在项目中只被编译一次。

#### C++中类成员中的访问权限和继承权限

#### cout和printf

printf是函数，cout是std::ostream的全局对象，<<对各种数据类型进行了重载，会自动识别数据类型。

cout是有缓冲输出，即输出字符先放入缓冲区，再输出到屏幕。

printf是行缓冲输出。

#### 重载运算符

允许程序员对自定义类和结构重载运算符，以像基本数据类型那样使用运算符，比如定义一个复数类，通过重载+运算符实现复数运算。

```c++
class Complex {
public:
    double real, imag;

    // 构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 重载+运算符
    Complex operator+(const Complex& b) const {
        return Complex(real + b.real, imag + b.imag);
    }
};
```

#### 对于函数重载，函数的匹配原则和顺序是什么

1. 精确匹配：参数类型完全一致
2. 提升匹配：比如将char类型参数提升到int
3. 标准转换匹配：比如int转到double，double转float
4. 最佳匹配：多个匹配，会根据上述顺序选择最佳

#### 定义和声明的区别

对于变量，声明就是告诉编译器变量的存在，不分配内存，定义则是为其分配内存，声明可以多次，定义只能一次。

函数的声明一般包括函数的签名，名字、参数列表和返回值。函数的定义包括具体的函数体

```c++
extern int x;  // 声明一个变量，但不定义它
void foo(int); // 函数声明，没有函数体
class Bar;     // 类的前向声明
int x;           // 变量定义，分配内存
void foo(int a) {
    // 函数定义，具体实现
    cout << a;
}
class Bar {
    // 类定义
    int b;
    void method() { cout << b; }
};
```

#### 全局变量和static变量

全局变量在整个程序都可见，static变量作用域限定为该文件，两者都在main启动前初始化。

#### 静态成员和普通成员

普通成员是每个对象都有，单独存储，只能通过类的对象访问

静态成员是整个类共享，可以通过类名访问，也可以通过类的对象访问

#### ifndef endif

如果没定义则定义，避免重复定义

#### 隐式转换，如何消除隐式转换

隐式转换是编译器自动进行的转换，比如将int类型赋值给float类型

在函数构造时加上explicit禁止隐式转换

#### C++如何处理多个异常

try throw catch（多个catch块）

#### 不使用额外空间交换两个数

```c++
1)  算术

x = x + y;
y = x - y;

x = x - y; 

2)  异或

x = x^y;// 只能对int,char..
y = x^y;
x = x^y;
x ^= y ^= x;
```

#### strcpy和memcpy的区别

```c++
char *strcpy(char *dest, const char *src)
void *memcpy(void *str1, const void *str2, size_t n)  
```

strcpy只能复制字符串，不用指定长度，会在遇到'\0'停止

memcpy可以复制任何内容，需要指定长度