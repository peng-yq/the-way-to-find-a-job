[最大切分乘积问题-Hello-Algo](https://www.hello-algo.com/chapter_greedy/max_product_cutting_problem/)

给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少。

## 动态规划

```c++
int integerBreak(int n) {
    vector<int> dp(n + 1, 0);
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i - j]));
        }
    }

    return dp[n];
}
```

动态规划的解法按套路就好了，创建一个n+1大小的dp数组，设定边界条件，即1不能被划分，因此dp[1]为1，其他元素i（从2开始）都能被划分为j和i-j。j和i-j都有两个状态即划分和不划分，对应dp[j]和dp[i-j]，同时j和i-j一定小于i，因此dp[j]和dp[i-j]此时是已知的。只需选择j和i-j划分和不划分最大的一个进行相乘，同样的i也有划分和不划分两种状态，选择最大的一个。

时间复杂度为$O(n^2)$，空间复杂度为$O(n)$

## 贪心算法

贪心算法的核心是每次选择都做最优的选择，同时保证局部最优能得到全局最优。

当从一个数n中分出一个因子2（因子1分出的结果只会小于其本身）时，何时两个因子乘积的结果大于其本身呢：

$$
n*(n-2) \geq n\\
n \geq 4
$$

说明所有大于等于4的元素都应该被划分，即划分出的因子为1、2和3，其中1已被排除。

2和3的情况中，当数为6时，$2*2*2<3*3$，因此2最多只能出现2次，3个2可以换成2个3。

因此对数n不断的切分出因子3，也就是对3求余：

- 余数为0，表示为3的倍数，不做任何处理
- 余数为1，需要将最后一个3替换为2，也就是$1*3 < 2*2$
- 余数为2，不再划分，也不做其他处理

时间复杂度取决于调用pow的时间复杂度，空间复杂度为$O(1)$。


