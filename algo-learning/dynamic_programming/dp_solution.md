[动态规划解题思路-Hello-Algo](https://www.hello-algo.com/chapter_dynamic_programming/dp_solution_pipeline/)

## 问题判断

DP问题的特点包括“重复子问题”、“最优化子问题”和“无后效性”。在判断一个问题是否可以使用DP算法，首先可以判断问题是否可以通过穷举的方式进行解决。此外，问题若出现以下特点，可能可以采用DP算法进行解决：

- 题目描述是求最优、最小等的解决方案
- 问题的状态可以用数组、矩阵等进行保存，并且有递推关系

若出现以下特点，则可能不适合DP算法：

- 题目是求取所有可能的解决方案，而非最优
- 题目需要返回具体的多个方案

## 问题求解步骤

通常来说，DP问题的求解步骤包括：“描述决策”、“定义状态”、“建立DP表”、“推导转移状态方程”和“确定边界条件”等。

给定一个n*m的二维网格grid ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。

<img src="https://www.hello-algo.com/chapter_dynamic_programming/dp_solution_pipeline.assets/min_path_sum_example.png">

首先可以判断这是一个典型的DP问题：

1. 可以通过穷举解决问题
2. 求取最小路径和
3. 重叠子问题
4. 最优子问题
5. 不用给出具体的移动步骤
6. 无后效性

### 描述决策

由于每次只能向下或向右移动一步，假设[i,j]表示第i行，第j列的格子，那么决策可能变化到[i+1, j]或者[i,j+1]。

### 定义状态

假设dp[i, j]表示从[0,0]格子到[i,j]格子的最小路径和。

### 建立DP表

每个格子对应一个状态，因此dp表大小与棋盘大小一致，需要dp[n][m]的空间。

### 推导转移状态方程

由于每次只能向下或者向右移动一步，因此dp[i][j] = min(dp[i-1][j]. dp[i][j-1]) + grid[i][j]

### 确定边界条件

由于dp子问题具有递推性，因此在编写求解状态转移方程时需要保证前面的解都求解完成，因此在这个题目下需要先对第一行（只能通过往右走得到）和第一列（只能通过往下走得到）的状态进行初始化。然后再对行列以内外循环的方式进行遍历。

```c++
int minPathSumDP(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dp(n, vector<int>(m));
    dp[0][0] = grid[0][0];
    for(int i = 1; i < n; i++)
        dp[i][0] = dp[i-1][0] + grid[i][0];
    for(int j = 1; j < m; j++)
        dp[0][j] = dp[0][j-1] + grid[0][j];
    for(int i = 1; i < n; i++){
        for(int j = 1; j < m; j++)
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; 
    }
    return dp[n-1][m-1];
}
```

时间复杂度与空间复杂度均为$O(nm)$。

**空间优化**：由于每次只能向下和向右移动一格，因此每个格子的状态只与上面与左边的格子有关，因此可以只使用一行大小为m的数组：

- 首先初始化第一行，第一行只能从左边的格子得到
- 依次递推其于行，首先需要初始化每一行的第一列的格子，这个格子只能从上面的格子向下移动得到；而其他的格子则是左边的格子与上方的格子（由于还没更新，因此dp[j]保存的是上方格子的值）的最小值加本格的值得到 

```c++
/* 最小路径和：空间优化后的动态规划 */
int minPathSumDPComp(vector<vector<int>> &grid) {
    int n = grid.size(), m = grid[0].size();
    // 初始化 dp 表
    vector<int> dp(m);
    // 状态转移：首行
    dp[0] = grid[0][0];
    for (int j = 1; j < m; j++) {
        dp[j] = dp[j - 1] + grid[0][j];
    }
    // 状态转移：其余行
    for (int i = 1; i < n; i++) {
        // 状态转移：首列
        dp[0] = dp[0] + grid[i][0];
        // 状态转移：其余列
        for (int j = 1; j < m; j++) {
            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];
        }
    }
    return dp[m - 1];
}
```

优化后的空间复杂度为$O(m)$。