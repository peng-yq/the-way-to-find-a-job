[动态规划问题特性-Hello-Algo](https://www.hello-algo.com/chapter_dynamic_programming/dp_problem_features/)

## 分治、回溯和动态规划

分治、回溯和动态规划三种解决思路有一些相似的特点。分治和动态规划很明显的将一个大问题分解为多个小问题，先得到小问题的解从而得到大问题的解；回溯我们也可以将一次次选择看做一个个的小问题，最后得到大问题的解；但这三种解决思路又不尽相同：

- 分治：可以使用分治算法的问题中，大问题可以分解为多个相似的、可独立解决的小问题，对小问题进行分别求解，逐步合并得到大问题的解
- 动态规划：动态规划问题往往解决思路是“从顶至底的”，但编写代码是“从底至顶的”。一是动态规划的各子问题是相互依赖的，即前面小问题先解出来才能得到后面小问题的解；此外为了提高效率，通过迭代来代替递归；动态规划求解的过程中会遇到许多重叠子问题，因此需要一个数组来保存子问题的解
- 回溯则是通过尝试和回退来穷举所有可能的解，并通过剪枝去除不符合条件的解

**动态优化算法往往用于解决最优化问题，这类问题通常拥有两种特性：最优子结构和无后效性**。

## 最优子结构

给定一个楼梯，你每步可以上1阶或者2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组cost，其中cost[i]表示在第i个台阶需要付出的代价，cost[0]为地面起始点。请计算最少需要付出多少代价才能到达顶部？

相较于普通的爬楼梯问题，描述增加了一个限制，即每爬上一层台阶都会付出一定的代价。但每步仍旧只能上1阶或者2阶，因此要到达第i阶，依旧只能从第i-1阶或者第i-2阶爬。假设dp[i]为到达第i阶所需付出的代价，由于第i层的代价是固定的cost[i]，为了要付出最少代价，因此需要选择dp[i-1]和dp[i-2]中最小的一个，也就是**当前问题的最优解是从子问题的最优解构建而来**。

```c++
int minCostClimbingStairsDP(vector<int> &cost) {
    int n = cost.size() - 1;
    if (n == 1 || n == 2)
        return cost[n];
    // 初始化 dp 表，用于存储子问题的解
    vector<int> dp(n + 1);
    // 初始状态：预设最小子问题的解
    dp[1] = cost[1];
    dp[2] = cost[2];
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return dp[n];
```

<img src="https://www.hello-algo.com/chapter_dynamic_programming/dp_problem_features.assets/min_cost_cs_dp.png">

## 无后效性

无后效的定义是：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历的所有状态均无关**。

例如爬楼梯问题中，第i层台阶可以发展出第i+1层台阶（爬1步）和第i+2层台阶（爬2步），这两个状态只与第i层台阶有关，与第i层台阶之前的所有状态均无关。

给定一个共有n阶的楼梯，你每步可以上1阶或者1阶，但不能连续两轮跳1阶，请问有多少种方案可以爬到楼顶。

这里增加了一个不能连续两轮跳1阶的约束，无后效性被破坏：如果去到第i层台阶的上一步是爬的1阶即从第i-1层爬，那么第i层台阶只能发展出第i+2层台阶；如果去到第i层台阶的上一步是爬的2阶即从第i-2层爬，那么第i层台阶可以发展出第i+1层台阶和第i+2层台阶。

但我们可以通过一些变化使得题目重新满足无后效性，假设dp[i,j]表示第i层，并且上一跳跳了j层（j为1或2）。

$$
\begin{cases}
dp[i, 1] = dp[i-1, 2] \\
dp[i, 2] = dp[i-2, 1] + dp[i-2, 2]
\end{cases}
$$

```c++
int climbingStairsConstraintDP(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    // 初始化 dp 表，用于存储子问题的解
    vector<vector<int>> dp(n + 1, vector<int>(3, 0));
    // 初始状态：预设最小子问题的解
    dp[1][1] = 1;
    dp[1][2] = 0;
    dp[2][1] = 0;
    dp[2][2] = 1;
    // 状态转移：从较小子问题逐步求解较大子问题
    for (int i = 3; i <= n; i++) {
        dp[i][1] = dp[i - 1][2];
        dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
    }
    return dp[n][1] + dp[n][2];
}
```

<img src="https://www.hello-algo.com/chapter_dynamic_programming/dp_problem_features.assets/climbing_stairs_constraint_state_transfer.png">

实际上，许多复杂的组合优化问题（例如旅行商问题）都不满足无后效性。对于这类问题，通常会选择使用其他方法，例如启发式搜索、遗传算法、强化学习等，从而在有限时间内得到可用的局部最优解。