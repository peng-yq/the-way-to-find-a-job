[构建树问题——Hello-Algo](https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/)

## 构建树问题

给定一个二叉树的前序遍历 preorder 和中序遍历 inorder ，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点。

<img src="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem.assets/build_tree_example.png">

根据前序遍历以及中序遍历构建二叉树是典型的分治问题（要构建二叉树至少需要有中序遍历，然后再加前序遍历或者后续遍历）：

- 构建树问题可以分为三个步骤：初始化根节点、构建左子树和构建右子树，也就是分为了两个子问题即左子树的构建和右子树的构建
- 对于每个子问题，按照上述方式进行处理，直到子树为空
- 对于每个子问题（构建左子树和构建右子树）是相互独立的，两边的节点数据不重合
- 当每个子问题得到解决（子树完成构建），将左右子树链接到根节点，从而得到大问题的解

## 子树划分

根据定义，preorder 和 inorder 都可以被划分为三个部分。

- 前序遍历：[ 根节点 | 左子树 | 右子树 ] ，例如[ 3 | 9 | 2 1 7 ] 。
- 中序遍历：[ 左子树 | 根节点 ｜ 右子树 ] ，例如[ 9 | 3 | 1 2 7 ] 。

可以发现我们通过前序遍历很容易得到根节点的值是3，通过查找根节点3在中序遍历的位置，从而在中序遍历数组中划分出左子树[9]和右子树[1 2 7]。

根据中序遍历数组中左右子树的节点数量，可以在前序遍历数组中完成左右子树的划分，即[9]和[2 1 7]。

再将右子树再次划分时，采用同样的方法，即2为根节点，查找2在中序遍历的位置，划分左右子树。

重复上述步骤直到左右子树不能再划分，从而返回并将解（子树）进行合并，完成二叉树的构建。

## 基于变量进行子树描述

- 当前树根节点在前序遍历数组的索引为i
- 当前树根节点在中序遍历数组的索引为m
- 当前树在中序遍历数组的索引区间为[l,r]

通过上述基础变量的定义即可完成左右子树及其根结点的相关定义：

- 当前树根节点在前序遍历数组的索引为i
- 当前树的左子树根节点在前序遍历数组的索引为i+1
- 当前树的右子树根节点在前序遍历数组的索引为i+1+(m-l)
- 当前树在中序遍历数组的索引区间为[l,r]
- 当前树的左子树在中序遍历数组的索引区间为[l,m-1]
- 当前树的右子树在中序遍历数组的索引区间为[m+1,r]

<img src="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem.assets/built_tree_overall.png">

## 算法特性

- 时间复杂度为$O(n)$
- 空间复杂度为$O(n)$，hashmap占用的空间