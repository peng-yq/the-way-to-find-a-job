[基数排序——Hello-Algo](https://www.hello-algo.com/chapter_sorting/radix_sort/)

## 基数排序

基数排序的核心思想和计数排序一致，通过统计个数来实现。基数排序通过数字各位之间的递进关系，依次对每位进行计数排序，从而完成排序。

以8位学号为例，通过基数排序进行排序的流程如下：
- 首先以学号的最后一位为基准，进行计数排序
- 然后对学号的倒数第二位进行计数排序
- 一直迭代直到对学号的第一位完成计数排序

> 试想如果是直接采用计数排序，辅助数组counter所占用的内存是很大的

<img src="https://www.hello-algo.com/chapter_sorting/radix_sort.assets/radix_sort_overview.png">

对于一个 $d$ 进制的数字 $x$ ，要获取其第 $k$ 位 $x_k$ （最低位为第1位） ，可以使用以下计算公式：

$$
x_k = \lfloor\frac{x}{d^{k-1}}\rfloor \bmod d
$$

其中 $\lfloor a \rfloor$ 表示对浮点数 $a$ 向下取整，而 $\bmod \: d$ 表示对 $d$ 取余。对于学号数据，$d = 10$ 且 $k \in [1, 8]$ 。

**之所以要从低位开始倒序排序，是因为每一轮计数排序都是只对一位进行排序，而后一轮的结果会覆盖前一轮的结果，因此需要先从低位进行排序**。

## 算法特性

**基数排序适合数值范围较大，但数据必须要能转换为固定位数的格式，且位数要小。浮点数不适合基数排序**。

- 时间复杂度为$O(nk)$：数据量为$n$，进制为$d$，最高位数为$k$，对每一位进行计数排序需要$O(n+d)$，$k$位则需要$O((n+d)k)$，当$d、k$都较小，时间复杂度趋向于$O(n)$
- 空间复杂度为$O(n+d)$，非原地排序
- 稳定排序

