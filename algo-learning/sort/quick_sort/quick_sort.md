[快速排序——Hello-Algo](https://www.hello-algo.com/chapter_sorting/quick_sort/)

## 哨兵划分

快速排序是一种**基于分治的排序策略**，核心操作是“哨兵划分”：选定数组中的一个数作为基准数，将所有小于基准数的元素移到其左侧，所有大于基准数的元素移到其右侧。

哨兵划分的流程：

1. 选取数组最左端的元素作为基准数，初始化两个指针i, j分别指向数组的最左端和最右端
2. 设置一个循环，每轮循环中使用i (j) 分别寻找第一个比基准数大（小）的元素，并交换这两个元素的位置
3. 执行循环直至i和j相等，然后将基准数交换至两个子数组的分界线（也就是i (j) 的位置）

哨兵划分后的数字将以基准数为界分为左右两个子数组，左子数组的元素均小于基准数，而右子数组的元素均大于基准数。

**需要注意的是哨兵划分后的左右子数组均未排序**。

因此**快速排序的分治策略体现在将一个较大数组的排序问题转换为两个较小数组的排序问题**。

## 快速排序

快速排序的整体流程：

1. 进行一次哨兵划分，将原数组变成未排序的左子数组和右子数组
2. 对左右子数组分别递归进行哨兵划分
3. 持续递归，直至子数组长度为1，完成整个数组的排序
   
## 算法特性

- 时间复杂度为$O(nlogn)$，最差时间复杂度（逆序）为$O(n^2)$
- 空间复杂度为$O(n)$，原地排序
- 非稳定排序（哨兵划分最后一步调整基准数位置导致）

快速排序的平均时间复杂度虽然和归并排序以及堆排序一致（$O(nlogn)$），但通常快速排序效率更高：

- 出现最差时间复杂度情况概率较低
- 缓存使用效率高，哨兵划分就将整个数组加入缓存
- 复杂度的常数系数低，比较、赋值和交换等操作的总数量最少

## 快速排序优化

快速排序在某些情况下效率会降低，例如数组为全逆序时，快速排序退化为冒泡排序。

快速排序的优化可通过**基准数优化（优化时间复杂度）**以及**尾递归优化（优化空间复杂度）**。

### 基准数优化

将数组元素的首、中、尾三个元素的中位数设定为基准数。

### 尾递归优化

每轮哨兵排序后，比较两子数组的长度，只对较短子数组进行递归。

